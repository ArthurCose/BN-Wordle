{"mappings":"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","sources":["<anon>","src/index.js","src/ui/game.js","src/ui/grid.js","src/input_manager.js","src/ui/shared_constants.js","src/ui/inventory.js","src/random.js","src/ui/run_line.js","src/ui/buttons.js","src/generation.js","src/shape.js","src/words.js","node_modules/array-shuffle/index.js"],"sourcesContent":["const $f8e847403f6cae58$export$17d7fd322af6b968 = {\n    UP: 0,\n    DOWN: 1,\n    LEFT: 2,\n    RIGHT: 3,\n    A: 4,\n    B: 5,\n    START: 6,\n    L: 7,\n    R: 8,\n    SIZE: 9\n};\nconst $f8e847403f6cae58$var$KeyboardBinding = {\n    ArrowUp: $f8e847403f6cae58$export$17d7fd322af6b968.UP,\n    ArrowDown: $f8e847403f6cae58$export$17d7fd322af6b968.DOWN,\n    ArrowLeft: $f8e847403f6cae58$export$17d7fd322af6b968.LEFT,\n    ArrowRight: $f8e847403f6cae58$export$17d7fd322af6b968.RIGHT,\n    KeyZ: $f8e847403f6cae58$export$17d7fd322af6b968.A,\n    KeyX: $f8e847403f6cae58$export$17d7fd322af6b968.B,\n    Enter: $f8e847403f6cae58$export$17d7fd322af6b968.START,\n    KeyA: $f8e847403f6cae58$export$17d7fd322af6b968.L,\n    KeyS: $f8e847403f6cae58$export$17d7fd322af6b968.R\n};\nclass $f8e847403f6cae58$export$2da2653229140a6c {\n    #pressed = [];\n    #repeated = [];\n    #held = [];\n    #released = [];\n    constructor(){\n        document.addEventListener(\"keydown\", (e)=>{\n            const input = $f8e847403f6cae58$var$KeyboardBinding[e.code];\n            if (input != undefined) {\n                this.simulateRepeat(input);\n                this.simulatePress(input);\n            }\n        });\n        document.addEventListener(\"keyup\", (e)=>{\n            const input = $f8e847403f6cae58$var$KeyboardBinding[e.code];\n            if (input != undefined) this.simulateRelease(input);\n        });\n    }\n    simulatePress(input) {\n        if (!this.#held[input]) {\n            this.#pressed[input] = true;\n            this.#held[input] = true;\n        }\n    }\n    simulateRepeat(input) {\n        // todo, handle using counters\n        if (this.#held[input]) this.#repeated[input] = true;\n    }\n    simulateRelease(input) {\n        if (input != undefined && this.#held[input]) {\n            this.#released[input] = true;\n            this.#held[input] = false;\n        }\n    }\n    justPressed(input) {\n        return this.#pressed[input] == true;\n    }\n    justRepeated(input) {\n        return this.#repeated[input] == true;\n    }\n    justReleased(input) {\n        return this.#released[input] == true;\n    }\n    isDown(input) {\n        return this.#held[input] == true;\n    }\n    flush() {\n        this.#pressed = [];\n        this.#released = [];\n        this.#repeated = [];\n    }\n}\n\n\nconst $00387b554b88a86f$export$4a4fccf86f542a62 = 240;\nconst $00387b554b88a86f$export$a94a52152a1b6dd0 = 160;\nconst $00387b554b88a86f$export$14a5666d9e2a0a92 = 20;\nconst $00387b554b88a86f$export$9188d4e069e95fa0 = 5;\nconst $00387b554b88a86f$export$d1ce89bfcf9b1ff3 = Math.floor($00387b554b88a86f$export$9188d4e069e95fa0 / 2);\nconst $00387b554b88a86f$export$ad58330ac2844faf = $00387b554b88a86f$export$9188d4e069e95fa0 * $00387b554b88a86f$export$14a5666d9e2a0a92;\nconst $00387b554b88a86f$export$1ac198198c587660 = $00387b554b88a86f$export$14a5666d9e2a0a92;\nconst $00387b554b88a86f$export$80b31447333fcc43 = $00387b554b88a86f$export$14a5666d9e2a0a92 * 1.5;\nconst $00387b554b88a86f$export$9556950d702f9ce3 = $00387b554b88a86f$export$1ac198198c587660 + $00387b554b88a86f$export$ad58330ac2844faf + $00387b554b88a86f$export$14a5666d9e2a0a92;\nconst $00387b554b88a86f$export$f8f3cccce646cdfb = $00387b554b88a86f$export$80b31447333fcc43;\nconst $00387b554b88a86f$export$56d196d2844d1ca1 = {\n    // shared\n    BOARD: \"darkorange\",\n    BORDER: \"#889EB3\",\n    // grid\n    GRID_BACKGROUND: \"#124D7F\",\n    GRID_CURSOR: \"lime\",\n    GRID_CURSOR_LETTER: \"#0006\",\n    LINE_SHADOW: \"#00000033\",\n    // line\n    PROCESSING_LETTER: \"WHITE\",\n    CORRECT_LETTER: \"lime\",\n    INCORRECT_LETTER: \"red\",\n    INVALID_LETTER: \"orange\",\n    // inventory\n    INVENTORY_CURSOR_BORDER: \"green\",\n    INVENTORY_CURSOR: \"lime\"\n};\n\n\nconst $30e9a94c591cfedc$var$GRID_BORDER_SIZE = 6;\nclass $30e9a94c591cfedc$export$2e2bcd8739ae039 {\n    #hasFocus = false;\n    #focusedTime = 0;\n    #selectedShape = null;\n    #shapes = [];\n    cursorPos = {\n        x: 2,\n        y: 2\n    };\n    onExit = ()=>{};\n    onReturnShape = (shape)=>{};\n    setShapes(shapes) {\n        this.#shapes = shapes;\n    }\n    selectShape(shape) {\n        this.#selectedShape = shape;\n    }\n    #hasSameColorNeighbor(shape, x, y) {\n        const hasSameColor = (x, y)=>{\n            const s = this.getShape(x, y);\n            return s && s != shape && s.color == shape.color;\n        };\n        return hasSameColor(x - 1, y) || hasSameColor(x + 1, y) || hasSameColor(x, y - 1) || hasSameColor(x, y + 1);\n    }\n    isValid() {\n        for(let y = 0; y < (0, $00387b554b88a86f$export$9188d4e069e95fa0); y++)for(let x = 0; x < (0, $00387b554b88a86f$export$9188d4e069e95fa0); x++){\n            const shape = this.getShape(x, y);\n            if (!shape) continue;\n            if (this.#hasSameColorNeighbor(shape, x, y)) return false;\n        }\n        return true;\n    }\n    #grabShape() {\n        const shape = this.getShape(this.cursorPos.x, this.cursorPos.y);\n        if (!shape) return null;\n        const index = this.#shapes.indexOf(shape);\n        this.#shapes.splice(index, 1);\n        this.#selectedShape = shape;\n        this.cursorPos.x = shape.x;\n        this.cursorPos.y = shape.y;\n        return shape;\n    }\n    #keepSelectedShapeInBounds() {\n        if (!this.#selectedShape) return;\n        let moved = false;\n        do {\n            for(let x = 0; x < (0, $00387b554b88a86f$export$9188d4e069e95fa0); x++){\n                if (this.#selectedShape.existsAt(x, -1)) this.#selectedShape.y += 1;\n                if (this.#selectedShape.existsAt(x, (0, $00387b554b88a86f$export$9188d4e069e95fa0))) this.#selectedShape.y -= 1;\n            }\n            for(let y = 0; y < (0, $00387b554b88a86f$export$9188d4e069e95fa0); y++){\n                if (this.#selectedShape.existsAt(-1, y)) this.#selectedShape.x += 1;\n                if (this.#selectedShape.existsAt((0, $00387b554b88a86f$export$9188d4e069e95fa0), y)) this.#selectedShape.x -= 1;\n            }\n        }while (moved);\n        this.cursorPos.x = this.#selectedShape.x;\n        this.cursorPos.y = this.#selectedShape.y;\n    }\n    #placeSelectedShape() {\n        if (!this.#selectedShape) return false;\n        for(let x = 0; x < (0, $00387b554b88a86f$export$9188d4e069e95fa0); x++)for(let y = 0; y < (0, $00387b554b88a86f$export$9188d4e069e95fa0); y++){\n            if (!this.#selectedShape.existsAt(x, y)) continue;\n            const shape = this.getShape(x, y);\n            if (shape) // todo: play sfx on fail?\n            return false;\n        }\n        this.#shapes.push(this.#selectedShape);\n        this.#selectedShape = null;\n        return true;\n    }\n    getShape(x, y) {\n        return this.#shapes.find((shape)=>shape.existsAt(x, y));\n    }\n    giveFocus() {\n        this.#hasFocus = true;\n        this.#focusedTime = 0;\n    }\n    removeFocus() {\n        this.#hasFocus = false;\n    }\n    update(inputManager, delta) {\n        this.#focusedTime += delta;\n        const left = inputManager.justPressed((0, $f8e847403f6cae58$export$17d7fd322af6b968).LEFT) || inputManager.justRepeated((0, $f8e847403f6cae58$export$17d7fd322af6b968).LEFT);\n        const right = inputManager.justPressed((0, $f8e847403f6cae58$export$17d7fd322af6b968).RIGHT) || inputManager.justRepeated((0, $f8e847403f6cae58$export$17d7fd322af6b968).RIGHT);\n        const up = inputManager.justPressed((0, $f8e847403f6cae58$export$17d7fd322af6b968).UP) || inputManager.justRepeated((0, $f8e847403f6cae58$export$17d7fd322af6b968).UP);\n        const down = inputManager.justPressed((0, $f8e847403f6cae58$export$17d7fd322af6b968).DOWN) || inputManager.justRepeated((0, $f8e847403f6cae58$export$17d7fd322af6b968).DOWN);\n        if (left) this.cursorPos.x -= 1;\n        if (right) this.cursorPos.x += 1;\n        if (up) this.cursorPos.y -= 1;\n        if (down) this.cursorPos.y += 1;\n        if (!this.#selectedShape && this.cursorPos.x >= (0, $00387b554b88a86f$export$9188d4e069e95fa0)) this.onExit(this.cursorPos);\n        this.cursorPos.x = Math.max(0, this.cursorPos.x);\n        this.cursorPos.x = Math.min((0, $00387b554b88a86f$export$9188d4e069e95fa0) - 1, this.cursorPos.x);\n        this.cursorPos.y = Math.max(0, this.cursorPos.y);\n        this.cursorPos.y = Math.min((0, $00387b554b88a86f$export$9188d4e069e95fa0) - 1, this.cursorPos.y);\n        if (this.#selectedShape) {\n            this.#selectedShape.x = this.cursorPos.x;\n            this.#selectedShape.y = this.cursorPos.y;\n            if (inputManager.justPressed((0, $f8e847403f6cae58$export$17d7fd322af6b968).L)) this.#selectedShape.rotateLeft();\n            if (inputManager.justPressed((0, $f8e847403f6cae58$export$17d7fd322af6b968).R)) this.#selectedShape.rotate();\n            this.#keepSelectedShapeInBounds();\n            if (inputManager.justPressed((0, $f8e847403f6cae58$export$17d7fd322af6b968).A)) this.#placeSelectedShape();\n            else if (inputManager.justPressed((0, $f8e847403f6cae58$export$17d7fd322af6b968).B)) {\n                const shape = this.#selectedShape;\n                this.#selectedShape = null;\n                this.#shapes = this.#shapes.filter((s)=>s != shape);\n                this.onReturnShape(shape);\n            }\n        } else {\n            if (inputManager.justPressed((0, $f8e847403f6cae58$export$17d7fd322af6b968).A)) this.#grabShape();\n            else if (inputManager.justPressed((0, $f8e847403f6cae58$export$17d7fd322af6b968).B)) this.onExit(this.cursorPos);\n        }\n    }\n    render(ctx) {\n        // border\n        ctx.fillStyle = (0, $00387b554b88a86f$export$56d196d2844d1ca1).BORDER;\n        ctx.fillRect((0, $00387b554b88a86f$export$1ac198198c587660) - $30e9a94c591cfedc$var$GRID_BORDER_SIZE, (0, $00387b554b88a86f$export$80b31447333fcc43) - $30e9a94c591cfedc$var$GRID_BORDER_SIZE, (0, $00387b554b88a86f$export$ad58330ac2844faf) + $30e9a94c591cfedc$var$GRID_BORDER_SIZE * 2, (0, $00387b554b88a86f$export$ad58330ac2844faf) + $30e9a94c591cfedc$var$GRID_BORDER_SIZE * 2);\n        // background\n        ctx.fillStyle = (0, $00387b554b88a86f$export$56d196d2844d1ca1).GRID_BACKGROUND;\n        ctx.fillRect((0, $00387b554b88a86f$export$1ac198198c587660), (0, $00387b554b88a86f$export$80b31447333fcc43), (0, $00387b554b88a86f$export$ad58330ac2844faf), (0, $00387b554b88a86f$export$ad58330ac2844faf));\n        // blocks\n        for(let x = 0; x < (0, $00387b554b88a86f$export$9188d4e069e95fa0); x++)for(let y = 0; y < (0, $00387b554b88a86f$export$9188d4e069e95fa0); y++){\n            const shape = this.getShape(x, y);\n            if (shape) {\n                ctx.fillStyle = shape.color;\n                ctx.fillRect((0, $00387b554b88a86f$export$1ac198198c587660) + (0, $00387b554b88a86f$export$14a5666d9e2a0a92) * x, (0, $00387b554b88a86f$export$80b31447333fcc43) + (0, $00387b554b88a86f$export$14a5666d9e2a0a92) * y, (0, $00387b554b88a86f$export$14a5666d9e2a0a92), (0, $00387b554b88a86f$export$14a5666d9e2a0a92));\n            }\n            if (this.#selectedShape && this.#selectedShape.existsAt(x, y)) {\n                ctx.globalAlpha = 0.75;\n                ctx.fillStyle = this.#selectedShape.color;\n                ctx.fillRect((0, $00387b554b88a86f$export$1ac198198c587660) + (0, $00387b554b88a86f$export$14a5666d9e2a0a92) * x, (0, $00387b554b88a86f$export$80b31447333fcc43) + (0, $00387b554b88a86f$export$14a5666d9e2a0a92) * y, (0, $00387b554b88a86f$export$14a5666d9e2a0a92), (0, $00387b554b88a86f$export$14a5666d9e2a0a92));\n                ctx.globalAlpha = 1;\n            }\n        }\n        ctx.fillStyle = (0, $00387b554b88a86f$export$56d196d2844d1ca1).LINE_SHADOW;\n        ctx.beginPath();\n        // to the right\n        ctx.moveTo((0, $00387b554b88a86f$export$1ac198198c587660), (0, $00387b554b88a86f$export$80b31447333fcc43) + (0, $00387b554b88a86f$export$14a5666d9e2a0a92) * 2);\n        ctx.lineTo((0, $00387b554b88a86f$export$1ac198198c587660) + (0, $00387b554b88a86f$export$ad58330ac2844faf), (0, $00387b554b88a86f$export$80b31447333fcc43) + (0, $00387b554b88a86f$export$14a5666d9e2a0a92) * 2);\n        // center\n        ctx.lineTo((0, $00387b554b88a86f$export$1ac198198c587660) + (0, $00387b554b88a86f$export$ad58330ac2844faf), (0, $00387b554b88a86f$export$80b31447333fcc43) + (0, $00387b554b88a86f$export$14a5666d9e2a0a92) * 2.5);\n        // back to the left\n        ctx.lineTo((0, $00387b554b88a86f$export$1ac198198c587660) + (0, $00387b554b88a86f$export$ad58330ac2844faf), (0, $00387b554b88a86f$export$80b31447333fcc43) + (0, $00387b554b88a86f$export$14a5666d9e2a0a92) * 3);\n        ctx.lineTo((0, $00387b554b88a86f$export$1ac198198c587660), (0, $00387b554b88a86f$export$80b31447333fcc43) + (0, $00387b554b88a86f$export$14a5666d9e2a0a92) * 3);\n        // auto closes\n        ctx.fill();\n        // draw cursor\n        if (this.#hasFocus) {\n            const { x: x, y: y } = this.cursorPos;\n            ctx.strokeStyle = (0, $00387b554b88a86f$export$56d196d2844d1ca1).GRID_CURSOR;\n            ctx.strokeRect((0, $00387b554b88a86f$export$1ac198198c587660) + (0, $00387b554b88a86f$export$14a5666d9e2a0a92) * x + 0.5, (0, $00387b554b88a86f$export$80b31447333fcc43) + (0, $00387b554b88a86f$export$14a5666d9e2a0a92) * y + 0.5, (0, $00387b554b88a86f$export$14a5666d9e2a0a92) - 1, (0, $00387b554b88a86f$export$14a5666d9e2a0a92) - 1);\n            // draw shape letter\n            const shape = this.getShape(x, y);\n            if (!this.#selectedShape && shape) {\n                ctx.fillStyle = (0, $00387b554b88a86f$export$56d196d2844d1ca1).GRID_CURSOR_LETTER;\n                ctx.font = \"16px bn6-bold\";\n                ctx.textBaseline = \"top\";\n                ctx.fillText(shape.letter, (0, $00387b554b88a86f$export$1ac198198c587660) + (0, $00387b554b88a86f$export$14a5666d9e2a0a92) * x + 6, (0, $00387b554b88a86f$export$80b31447333fcc43) + (0, $00387b554b88a86f$export$14a5666d9e2a0a92) * y + 3);\n            }\n        }\n    }\n}\n\n\n\n\n// [0, n)\nfunction $2ce087bca3075e18$export$3c5f89dae98e900b(n) {\n    return Math.floor(Math.random() * n);\n}\nfunction $2ce087bca3075e18$export$114aa43ee4755930(array) {\n    return array[$2ce087bca3075e18$export$3c5f89dae98e900b(array.length)];\n}\n\n\nclass $376aef2b802d0445$export$2e2bcd8739ae039 {\n    #hasFocus = false;\n    #focusTime = 0;\n    #shapes = [];\n    cursorIndex = 0;\n    onRun = ()=>{};\n    onExit = (gridPos)=>{};\n    onSelection = (shape)=>{};\n    giveFocus() {\n        this.#hasFocus = true;\n        this.#focusTime = 0;\n    }\n    removeFocus() {\n        this.#hasFocus = false;\n        this.#focusTime = 0;\n    }\n    setShapes(shapes) {\n        shapes.forEach((shape)=>{\n            shape.x = Math.floor((0, $00387b554b88a86f$export$9188d4e069e95fa0) / 2);\n            shape.y = Math.floor((0, $00387b554b88a86f$export$9188d4e069e95fa0) / 2);\n            shape.rotation = (0, $2ce087bca3075e18$export$3c5f89dae98e900b)(4);\n        });\n        this.#shapes = shapes;\n    }\n    addShape(shape) {\n        shape.x = Math.floor((0, $00387b554b88a86f$export$9188d4e069e95fa0) / 2);\n        shape.y = Math.floor((0, $00387b554b88a86f$export$9188d4e069e95fa0) / 2);\n        this.#shapes.push(shape);\n    }\n    update(inputManager, delta) {\n        this.#focusTime += delta;\n        if (inputManager.justPressed((0, $f8e847403f6cae58$export$17d7fd322af6b968).LEFT)) {\n            this.onExit(this.cursorIndex);\n            return;\n        }\n        const pressedUp = inputManager.justPressed((0, $f8e847403f6cae58$export$17d7fd322af6b968).UP) || inputManager.justRepeated((0, $f8e847403f6cae58$export$17d7fd322af6b968).UP);\n        const pressedDown = inputManager.justPressed((0, $f8e847403f6cae58$export$17d7fd322af6b968).DOWN) || inputManager.justRepeated((0, $f8e847403f6cae58$export$17d7fd322af6b968).DOWN);\n        if (pressedUp) this.cursorIndex -= 1;\n        if (pressedDown) this.cursorIndex += 1;\n        this.cursorIndex = Math.max(0, this.cursorIndex);\n        this.cursorIndex = Math.min(this.#shapes.length, this.cursorIndex);\n        if (inputManager.justPressed((0, $f8e847403f6cae58$export$17d7fd322af6b968).A)) {\n            if (this.cursorIndex < this.#shapes.length) {\n                const [removedShape] = this.#shapes.splice(this.cursorIndex, 1);\n                this.onSelection(removedShape);\n            } else this.onRun();\n        }\n    }\n    render(ctx) {\n        ctx.font = \"16px bn6-bold\";\n        ctx.textBaseline = \"top\";\n        const width = 26;\n        const height = 15;\n        for(let i = 0; i < this.#shapes.length; i++){\n            const shape = this.#shapes[i];\n            const startX = (0, $00387b554b88a86f$export$9556950d702f9ce3);\n            const startY = (0, $00387b554b88a86f$export$f8f3cccce646cdfb) + (0, $00387b554b88a86f$export$14a5666d9e2a0a92) * i;\n            // render border\n            ctx.fillStyle = (0, $00387b554b88a86f$export$56d196d2844d1ca1).BORDER;\n            ctx.fillRect(startX - 2, startY - 2, width + 4, height + 4);\n            // render bg\n            ctx.fillStyle = (0, $00387b554b88a86f$export$56d196d2844d1ca1).GRID_BACKGROUND;\n            ctx.fillRect(startX, startY, width, height);\n            // render mini shape\n            ctx.fillStyle = shape.color;\n            for(let x = 0; x < 5; x++)for(let y = 0; y < 5; y++){\n                if (!shape.existsAt(x, y)) continue;\n                ctx.fillRect(startX + x * 3 + 11, startY + y * 3, 3, 3);\n            }\n            ctx.fillStyle = \"white\";\n            ctx.fillText(shape.letter, startX + 1, startY + 1);\n        }\n        // render run button\n        {\n            const startX = (0, $00387b554b88a86f$export$9556950d702f9ce3);\n            const startY = (0, $00387b554b88a86f$export$f8f3cccce646cdfb) + (0, $00387b554b88a86f$export$14a5666d9e2a0a92) * this.#shapes.length;\n            // render border\n            ctx.fillStyle = (0, $00387b554b88a86f$export$56d196d2844d1ca1).BORDER;\n            ctx.fillRect(startX - 2, startY - 2, width + 4, height + 4);\n            // render bg\n            ctx.fillStyle = \"lime\";\n            ctx.fillRect(startX, startY, width, height);\n            ctx.fillStyle = \"white\";\n            ctx.fillText(\"RUN\", startX + 1, startY + 1);\n        }\n        if (this.#hasFocus) {\n            const startX = (0, $00387b554b88a86f$export$9556950d702f9ce3) - 9 + Math.sin(this.#focusTime * 16);\n            const startY = (0, $00387b554b88a86f$export$f8f3cccce646cdfb) + (0, $00387b554b88a86f$export$14a5666d9e2a0a92) * this.cursorIndex;\n            ctx.strokeStyle = (0, $00387b554b88a86f$export$56d196d2844d1ca1).INVENTORY_CURSOR_BORDER;\n            ctx.fillStyle = (0, $00387b554b88a86f$export$56d196d2844d1ca1).INVENTORY_CURSOR;\n            ctx.beginPath();\n            ctx.moveTo(startX, startY);\n            ctx.lineTo(startX + 8, startY + height / 2);\n            ctx.lineTo(startX, startY + height);\n            ctx.closePath();\n            ctx.fill();\n            ctx.stroke();\n        }\n    }\n}\n\n\n\n\nclass $47117747e6c50692$export$2e2bcd8739ae039 {\n    #progress = 0;\n    #grid;\n    #word;\n    #builtWord;\n    #validGrid;\n    constructor(grid, word){\n        this.#grid = grid;\n    }\n    onSuccess = ()=>{};\n    onExit = ()=>{};\n    setWord(word) {\n        this.#word = word;\n    }\n    giveFocus() {\n        this.#progress = 0;\n        this.#builtWord = null;\n    }\n    removeFocus() {\n        this.#progress = 0;\n    }\n    #reviewGrid() {\n        this.#builtWord = \"\";\n        for(let i = 0; i < (0, $00387b554b88a86f$export$9188d4e069e95fa0); i++){\n            const shape = this.#grid.getShape(i, (0, $00387b554b88a86f$export$d1ce89bfcf9b1ff3));\n            this.#builtWord += shape ? shape.letter : \"?\";\n        }\n        this.#validGrid = this.#grid.isValid();\n    }\n    update(inputManager, delta) {\n        this.#progress = Math.min(1, this.#progress + delta / 2);\n        const accept = inputManager.justPressed((0, $f8e847403f6cae58$export$17d7fd322af6b968).A);\n        const cancel = inputManager.justPressed((0, $f8e847403f6cae58$export$17d7fd322af6b968).B);\n        if ((accept || cancel) && this.#progress == 1) this.onExit();\n        if (!this.#builtWord && this.#progress == 1) this.#reviewGrid();\n    }\n    #renderLine(ctx) {\n        ctx.beginPath();\n        const progressWidth = (0, $00387b554b88a86f$export$ad58330ac2844faf) * this.#progress;\n        // to the right\n        ctx.moveTo((0, $00387b554b88a86f$export$1ac198198c587660), (0, $00387b554b88a86f$export$80b31447333fcc43) + (0, $00387b554b88a86f$export$14a5666d9e2a0a92) * 2);\n        ctx.lineTo((0, $00387b554b88a86f$export$1ac198198c587660) + progressWidth, (0, $00387b554b88a86f$export$80b31447333fcc43) + (0, $00387b554b88a86f$export$14a5666d9e2a0a92) * 2);\n        // center\n        ctx.lineTo((0, $00387b554b88a86f$export$1ac198198c587660) + progressWidth, (0, $00387b554b88a86f$export$80b31447333fcc43) + (0, $00387b554b88a86f$export$14a5666d9e2a0a92) * 2.5);\n        // back to the left\n        ctx.lineTo((0, $00387b554b88a86f$export$1ac198198c587660) + progressWidth, (0, $00387b554b88a86f$export$80b31447333fcc43) + (0, $00387b554b88a86f$export$14a5666d9e2a0a92) * 3);\n        ctx.lineTo((0, $00387b554b88a86f$export$1ac198198c587660), (0, $00387b554b88a86f$export$80b31447333fcc43) + (0, $00387b554b88a86f$export$14a5666d9e2a0a92) * 3);\n        ctx.fill();\n    }\n    #renderText(ctx, offsetX, offsetY) {\n        for(let i = 0; i < (0, $00387b554b88a86f$export$9188d4e069e95fa0) * this.#progress - 0.5; i++){\n            const shape = this.#grid.getShape(i, (0, $00387b554b88a86f$export$d1ce89bfcf9b1ff3));\n            ctx.font = \"16px bn6-bold\";\n            ctx.fillText(shape ? shape.letter : \"?\", (0, $00387b554b88a86f$export$1ac198198c587660) + (0, $00387b554b88a86f$export$14a5666d9e2a0a92) * i + 6 + offsetX, (0, $00387b554b88a86f$export$80b31447333fcc43) + (0, $00387b554b88a86f$export$14a5666d9e2a0a92) * (0, $00387b554b88a86f$export$d1ce89bfcf9b1ff3) + 3 + offsetY);\n        }\n    }\n    render(ctx) {\n        ctx.fillStyle = \"#ffff0066\";\n        this.#renderLine(ctx);\n        let text_color;\n        if (this.#progress < 1) text_color = (0, $00387b554b88a86f$export$56d196d2844d1ca1).PROCESSING_LETTER;\n        else if (this.#builtWord == this.#word) text_color = this.#validGrid ? (0, $00387b554b88a86f$export$56d196d2844d1ca1).CORRECT_LETTER : (0, $00387b554b88a86f$export$56d196d2844d1ca1).INVALID_LETTER;\n        else text_color = (0, $00387b554b88a86f$export$56d196d2844d1ca1).INCORRECT_LETTER;\n        // text shadow\n        ctx.fillStyle = text_color;\n        ctx.globalAlpha = 0.5;\n        this.#renderText(ctx, 1, 1);\n        // darken shadow\n        ctx.fillStyle = \"black\";\n        ctx.globalAlpha = 0.5;\n        this.#renderText(ctx, 1, 1);\n        // draw text\n        ctx.globalAlpha = 1;\n        ctx.fillStyle = text_color;\n        this.#renderText(ctx, 0, 0);\n    }\n}\n\n\n\n\nconst $35d204e98b857052$var$BUTTON_SIZE = 24;\nclass $35d204e98b857052$export$2e2bcd8739ae039 {\n    #buttons = [\n        {\n            binding: (0, $f8e847403f6cae58$export$17d7fd322af6b968).L,\n            x: 0,\n            y: 1,\n            w: 2,\n            h: 1\n        },\n        {\n            binding: (0, $f8e847403f6cae58$export$17d7fd322af6b968).R,\n            x: (0, $00387b554b88a86f$export$4a4fccf86f542a62) / $35d204e98b857052$var$BUTTON_SIZE - 2,\n            y: 1,\n            w: 2,\n            h: 1\n        },\n        {\n            binding: (0, $f8e847403f6cae58$export$17d7fd322af6b968).LEFT,\n            x: 1,\n            y: 4,\n            w: 1,\n            h: 1\n        },\n        {\n            binding: (0, $f8e847403f6cae58$export$17d7fd322af6b968).RIGHT,\n            x: 3,\n            y: 4,\n            w: 1,\n            h: 1\n        },\n        {\n            binding: (0, $f8e847403f6cae58$export$17d7fd322af6b968).UP,\n            x: 2,\n            y: 3,\n            w: 1,\n            h: 1\n        },\n        {\n            binding: (0, $f8e847403f6cae58$export$17d7fd322af6b968).DOWN,\n            x: 2,\n            y: 5,\n            w: 1,\n            h: 1\n        },\n        {\n            binding: (0, $f8e847403f6cae58$export$17d7fd322af6b968).A,\n            x: (0, $00387b554b88a86f$export$4a4fccf86f542a62) / $35d204e98b857052$var$BUTTON_SIZE - 3,\n            y: 3,\n            w: 1,\n            h: 1\n        },\n        {\n            binding: (0, $f8e847403f6cae58$export$17d7fd322af6b968).B,\n            x: (0, $00387b554b88a86f$export$4a4fccf86f542a62) / $35d204e98b857052$var$BUTTON_SIZE - 4,\n            y: 4,\n            w: 1,\n            h: 1\n        }\n    ];\n    #canvas;\n    #state = [];\n    #inputManager;\n    constructor(canvas, inputManager){\n        this.#canvas = canvas;\n        this.#inputManager = inputManager;\n        canvas.addEventListener(\"touchstart\", (e)=>{\n            this.#updateFromTouchEvent(e);\n        });\n        canvas.addEventListener(\"touchmove\", (e)=>{\n            this.#updateFromTouchEvent(e);\n        });\n        canvas.addEventListener(\"touchend\", (e)=>{\n            this.#updateFromTouchEvent(e);\n        });\n    }\n    #updateFromTouchEvent(event) {\n        const canvas = this.#canvas;\n        const canvasRect = canvas.getBoundingClientRect();\n        const newState = [];\n        for (const touch of event.targetTouches){\n            // get corrected canvas position\n            let x = (touch.clientX - canvasRect.x) / canvasRect.width * canvas.width;\n            let y = (touch.clientY - canvasRect.y) / canvasRect.height * canvas.height;\n            // transform position to button space\n            x = x / $35d204e98b857052$var$BUTTON_SIZE;\n            y = (y - (0, $00387b554b88a86f$export$a94a52152a1b6dd0)) / $35d204e98b857052$var$BUTTON_SIZE;\n            for (const button of this.#buttons)if (x > button.x && y > button.y && x < button.x + button.w && y < button.y + button.h) newState[button.binding] = true;\n        }\n        for(let i = 0; i < (0, $f8e847403f6cae58$export$17d7fd322af6b968).SIZE; i++){\n            if (this.#state[i] && !newState[i]) this.#inputManager.simulateRelease(i);\n            else if (!this.#state[i] && newState[i]) this.#inputManager.simulatePress(i);\n        }\n        this.#state = newState;\n    }\n    update() {\n        for(let i = 0; i < (0, $f8e847403f6cae58$export$17d7fd322af6b968).SIZE; i++)if (this.#state[i]) this.#inputManager.simulatePress(i);\n    }\n    render(ctx) {\n        ctx.fillStyle = \"white\";\n        for (const button of this.#buttons)ctx.fillRect(button.x * $35d204e98b857052$var$BUTTON_SIZE, (0, $00387b554b88a86f$export$a94a52152a1b6dd0) + button.y * $35d204e98b857052$var$BUTTON_SIZE, button.w * $35d204e98b857052$var$BUTTON_SIZE, button.h * $35d204e98b857052$var$BUTTON_SIZE);\n    }\n}\n\n\n\n\n\nconst $d12e779adf4758b5$var$MAX_SHAPE_SIDE_LEN = 5;\nconst $d12e779adf4758b5$var$CENTER_LEN = Math.floor($d12e779adf4758b5$var$MAX_SHAPE_SIDE_LEN / 2);\nclass $d12e779adf4758b5$export$2e2bcd8739ae039 {\n    #blocks = [];\n    constructor(){\n        this.color = \"\";\n        this.letter = \"\";\n        this.x = 0;\n        this.y = 0;\n        this.rotation = 0;\n        for(let i = 0; i < $d12e779adf4758b5$var$MAX_SHAPE_SIDE_LEN * $d12e779adf4758b5$var$MAX_SHAPE_SIDE_LEN; i++)this.#blocks[i] = false;\n    }\n    isColumn() {\n        let count = 0;\n        for(let i = 0; i < $d12e779adf4758b5$var$MAX_SHAPE_SIDE_LEN; i++)for(let j = 0; j < $d12e779adf4758b5$var$MAX_SHAPE_SIDE_LEN; j++){\n            const index = i * $d12e779adf4758b5$var$MAX_SHAPE_SIDE_LEN + j;\n            if (!this.#blocks[index]) continue;\n            if (j != $d12e779adf4758b5$var$CENTER_LEN) // found a block outside of a column\n            return false;\n            count++;\n        }\n        // 1x1 is not a column\n        return count > 1;\n    }\n    rotate() {\n        this.rotation += 1;\n        this.rotation %= 4;\n    }\n    rotateLeft() {\n        this.rotation -= 1;\n        if (this.rotation < 0) this.rotation = 3;\n    }\n    canSet(x, y) {\n        const index = this.getIndex(x, y);\n        return index >= 0 && index < $d12e779adf4758b5$var$MAX_SHAPE_SIDE_LEN * $d12e779adf4758b5$var$MAX_SHAPE_SIDE_LEN;\n    }\n    set(x, y, value) {\n        const index = this.getIndex(x, y);\n        this.#blocks[index] = value;\n    }\n    existsAt(x, y) {\n        const index = this.getIndex(x, y);\n        return this.#blocks[index] == true;\n    }\n    countBlocks() {\n        let count = 0;\n        for(let i = 0; i < this.#blocks.length; i++)if (this.#blocks[i]) count++;\n        return count;\n    }\n    recalculateCenter() {\n        const bounds = {\n            top: 0,\n            bottom: 0,\n            left: 0,\n            right: 0\n        };\n        const validPositions = [];\n        for(let i = 0; i < $d12e779adf4758b5$var$MAX_SHAPE_SIDE_LEN; i++)for(let j = 0; j < $d12e779adf4758b5$var$MAX_SHAPE_SIDE_LEN; j++){\n            const index = i * $d12e779adf4758b5$var$MAX_SHAPE_SIDE_LEN + j;\n            if (!this.#blocks[index]) continue;\n            const x = j - $d12e779adf4758b5$var$CENTER_LEN;\n            const y = i - $d12e779adf4758b5$var$CENTER_LEN;\n            if (x < bounds.left) bounds.left = x;\n            if (y < bounds.top) bounds.top = y;\n            if (x > bounds.right) bounds.right = x;\n            if (y > bounds.bottom) bounds.bottom = y;\n            validPositions.push({\n                x: x,\n                y: y\n            });\n        }\n        const trueCenter = {\n            x: (bounds.left + bounds.right) / 2,\n            y: (bounds.bottom + bounds.top) / 2\n        };\n        validPositions.sort((posA, posB)=>{\n            const manhattanDistA = Math.abs(trueCenter.x - posA.x) + Math.abs(trueCenter.y - posA.y);\n            const manhattanDistB = Math.abs(trueCenter.x - posB.x) + Math.abs(trueCenter.y - posB.y);\n            return manhattanDistA < manhattanDistB ? -1 : 1;\n        });\n        const newCenter = validPositions[0];\n        this.x -= newCenter.x;\n        this.y -= newCenter.y;\n        const updatedBlocks = [\n            ...this.#blocks\n        ];\n        for(let i = 0; i < $d12e779adf4758b5$var$MAX_SHAPE_SIDE_LEN; i++)for(let j = 0; j < $d12e779adf4758b5$var$MAX_SHAPE_SIDE_LEN; j++){\n            let value = false;\n            const oldX = j + newCenter.x;\n            const oldY = i + newCenter.y;\n            if (oldX >= 0 && oldY >= 0 && oldX < $d12e779adf4758b5$var$MAX_SHAPE_SIDE_LEN && oldY < $d12e779adf4758b5$var$MAX_SHAPE_SIDE_LEN) {\n                const index = oldY * $d12e779adf4758b5$var$MAX_SHAPE_SIDE_LEN + oldX;\n                value = this.#blocks[index];\n            }\n            const index = i * $d12e779adf4758b5$var$MAX_SHAPE_SIDE_LEN + j;\n            updatedBlocks[index] = value;\n        }\n        this.#blocks = updatedBlocks;\n    }\n    getIndex(x, y) {\n        x = x - this.x;\n        y = y - this.y;\n        let transformedX, transformedY;\n        switch(this.rotation){\n            case 0:\n                // [x-y-, x+y-]\n                // [x-y+, x+y+]\n                transformedX = x;\n                transformedY = y;\n                break;\n            case 1:\n                // 90 clockwise\n                // [x-y+, x-y-]\n                // [x+y+, x+y-]\n                transformedX = y;\n                transformedY = $d12e779adf4758b5$var$CENTER_LEN - x - 2;\n                break;\n            case 2:\n                // 180\n                // [x+y+, x-y+]\n                // [x+y-, x-y-]\n                transformedX = $d12e779adf4758b5$var$CENTER_LEN - x - 2;\n                transformedY = $d12e779adf4758b5$var$CENTER_LEN - y - 2;\n                break;\n            case 3:\n                // 270\n                // [x+y-, x+y+]\n                // [x-y-, x-y+]\n                transformedX = $d12e779adf4758b5$var$CENTER_LEN - y - 2;\n                transformedY = x;\n                break;\n        }\n        transformedX += $d12e779adf4758b5$var$CENTER_LEN;\n        transformedY += $d12e779adf4758b5$var$CENTER_LEN;\n        if (transformedX < 0 || transformedY < 0 || transformedX >= $d12e779adf4758b5$var$MAX_SHAPE_SIDE_LEN || transformedY >= $d12e779adf4758b5$var$MAX_SHAPE_SIDE_LEN) return -1;\n        return transformedY * $d12e779adf4758b5$var$MAX_SHAPE_SIDE_LEN + transformedX;\n    }\n}\n\n\n\nconst $2a59e984b87de363$var$GRID_SIDE_LEN = 5;\nlet $2a59e984b87de363$var$COLORS = [\n    \"#DE1100\",\n    \"#D688C0\",\n    \"#2880D9\",\n    \"#19C000\",\n    \"#D8DA00\",\n    \"#D8D8D8\"\n];\nconst $2a59e984b87de363$var$MAX_SHAPE_SIZE = 4;\nconst $2a59e984b87de363$var$MAX_COLORS = 4;\nfunction $2a59e984b87de363$var$generateColors() {\n    const colors = [];\n    while(colors.length < $2a59e984b87de363$var$MAX_COLORS){\n        const color = (0, $2ce087bca3075e18$export$114aa43ee4755930)($2a59e984b87de363$var$COLORS);\n        if (!colors.includes(color)) colors.push(color);\n    }\n    return colors;\n}\nfunction $2a59e984b87de363$var$internalGenerateWordShapes(word) {\n    let shapes = [];\n    let nextRun = [];\n    let colors = $2a59e984b87de363$var$generateColors();\n    let colorOffset = (0, $2ce087bca3075e18$export$3c5f89dae98e900b)(colors.length);\n    for(let i = 0; i < $2a59e984b87de363$var$GRID_SIDE_LEN; i++){\n        const shape = new (0, $d12e779adf4758b5$export$2e2bcd8739ae039)();\n        shape.color = colors[(i + colorOffset) % colors.length];\n        shape.x = i;\n        shape.y = 2;\n        shape.letter = word[i];\n        shape.set(shape.x, shape.y, true);\n        shapes.push(shape);\n        nextRun.push({\n            shape: shape,\n            x: shape.x,\n            y: shape.y - 1\n        });\n        nextRun.push({\n            shape: shape,\n            x: shape.x,\n            y: shape.y + 1\n        });\n        if (word[i] == word[i + 1]) {\n            // merge repeated letter\n            shape.set(shape.x + 1, shape.y, true);\n            i++;\n            nextRun.push({\n                shape: shape,\n                x: shape.x + 1,\n                y: shape.y - 1\n            });\n            nextRun.push({\n                shape: shape,\n                x: shape.x + 1,\n                y: shape.y + 1\n            });\n        }\n    }\n    const spread = ({ shape: shape, x: x, y: y })=>{\n        nextRun.push({\n            shape: shape,\n            x: x - 1,\n            y: y\n        });\n        nextRun.push({\n            shape: shape,\n            x: x + 1,\n            y: y\n        });\n        nextRun.push({\n            shape: shape,\n            x: x,\n            y: y - 1\n        });\n        nextRun.push({\n            shape: shape,\n            x: x,\n            y: y + 1\n        });\n    };\n    function hasSameColorNeighbor(shape, x, y) {\n        function hasSameColor(x, y) {\n            const s = shapes.find((shape)=>shape.existsAt(x, y));\n            return s && s != shape && s.color == shape.color;\n        }\n        return hasSameColor(x - 1, y) || hasSameColor(x + 1, y) || hasSameColor(x, y - 1) || hasSameColor(x, y + 1);\n    }\n    while(nextRun.length > 0){\n        const run = nextRun;\n        nextRun = [];\n        for (const { shape: shape, x: x, y: y } of run){\n            if (x < 0 || y < 0 || x >= $2a59e984b87de363$var$GRID_SIDE_LEN || y >= $2a59e984b87de363$var$GRID_SIDE_LEN) continue;\n            const otherShape = shapes.find((shape)=>shape.existsAt(x, y));\n            if (otherShape) continue;\n            const growShape = ()=>{\n                // spread if we can, or drop this search\n                if (hasSameColorNeighbor(shape, x, y)) return;\n                if (shape.countBlocks() >= $2a59e984b87de363$var$MAX_SHAPE_SIZE || !shape.canSet(x, y)) return;\n                shape.set(x, y, true);\n                spread({\n                    shape: shape,\n                    x: x,\n                    y: y\n                });\n            };\n            const tryLater = ()=>{\n                // do nothing, but try again next run\n                nextRun.push({\n                    shape: shape,\n                    x: x,\n                    y: y\n                });\n            };\n            const options = [\n                growShape,\n                tryLater\n            ];\n            (0, $2ce087bca3075e18$export$114aa43ee4755930)(options)();\n        }\n    }\n    return shapes;\n}\nfunction $2a59e984b87de363$export$118f84f93f08b80c(word) {\n    let shapes;\n    do shapes = $2a59e984b87de363$var$internalGenerateWordShapes(word);\n    while (shapes.filter((shape)=>shape.isColumn()).length > 1);\n    for (const shape of shapes)shape.recalculateCenter();\n    return shapes;\n}\nfunction $2a59e984b87de363$export$c89aaa4a593054ed(word) {\n    let shapes;\n    do shapes = $2a59e984b87de363$var$internalGenerateWordShapes(word);\n    while (shapes.filter((shape)=>shape.isColumn()).length > 1);\n    return shapes;\n}\n\n\nvar $09b17a1eda282565$export$2e2bcd8739ae039 = [\n    // misc\n    \"ZENNY\",\n    \"CHIPS\",\n    \"CYBER\",\n    \"PANEL\",\n    \"COLOR\",\n    \"POINT\",\n    \"GAUGE\",\n    \"VIRUS\",\n    \"DRILL\",\n    \"SNEAK\",\n    \"HPMEM\",\n    \"BREAK\",\n    // NCP\n    \"SHOES\",\n    \"HUMOR\",\n    \"TANGO\",\n    \"ARMOR\",\n    \"BLOCK\",\n    // humans\n    \"CHAUD\",\n    \"BARYL\",\n    // navis\n    \"GLIDE\",\n    \"PROTO\",\n    // \"NUMBR\", // NumbrMan Chips + NumberMan\n    \"MAGIC\",\n    \"SKULL\",\n    \"SHARK\",\n    \"PHARO\",\n    // \"SHADO\",\n    // \"MAGNT\",\n    // \"NAPLM\",\n    \"METAL\",\n    \"JAPAN\",\n    // \"BUBBL\",\n    \"SPARK\",\n    \"VIDEO\",\n    \"SHADE\",\n    \"COSMO\",\n    \"MEDDY\",\n    \"CHAOS\",\n    \"SPOUT\",\n    \"BLAST\",\n    \"JUDGE\",\n    \"ERASE\",\n    \"TENGU\",\n    \"BEAST\",\n    \"CACHE\",\n    \"KENDO\",\n    \"LASER\",\n    \"QUICK\",\n    \"STONE\",\n    // chips\n    \"STEAL\",\n    \"CLOUD\",\n    \"INVIS\",\n    \"POPUP\",\n    \"SWORD\",\n    \"BLADE\",\n    \"PUNCH\",\n    \"LANCE\",\n    \"GUARD\",\n    \"RECOV\",\n    \"ARROW\",\n    \"SPICE\",\n    \"SHAKE\",\n    \"PANIC\",\n    \"BATCH\",\n    \"SNAKE\",\n    \"QUAKE\",\n    \"DELTA\",\n    \"STAGE\",\n    // viruses\n    \"BILLY\",\n    \"FISHY\",\n    \"RATTY\",\n    \"PUFFY\",\n    \"JELLY\",\n    \"BUNNY\",\n    \"POWIE\",\n    \"PENGI\",\n    \"VINEY\",\n    \"ALPHA\",\n    \"TOTEM\",\n    \"TWINS\",\n    \"KILBY\",\n    \"WALLA\",\n    \"BATTY\",\n    \"HANDI\",\n    \"ZOMON\",\n    \"BRUTE\",\n    \"HEADY\",\n    \"GOLEM\"\n];\n\n\nfunction $d8bf78f2b5ef2882$export$2e2bcd8739ae039(array) {\n    if (!Array.isArray(array)) throw new TypeError(`Expected an array, got ${typeof array}`);\n    array = [\n        ...array\n    ];\n    for(let index = array.length - 1; index > 0; index--){\n        const newIndex = Math.floor(Math.random() * (index + 1));\n        [array[index], array[newIndex]] = [\n            array[newIndex],\n            array[index]\n        ];\n    }\n    return array;\n}\n\n\nclass $2fdd4cd8dcfa2293$export$2e2bcd8739ae039 {\n    #inventory = new (0, $376aef2b802d0445$export$2e2bcd8739ae039)();\n    #grid = new (0, $30e9a94c591cfedc$export$2e2bcd8739ae039)();\n    #runLine = new (0, $47117747e6c50692$export$2e2bcd8739ae039)(this.#grid);\n    #buttons;\n    #focusedUI = this.#inventory;\n    #inputManager = new (0, $f8e847403f6cae58$export$2da2653229140a6c)();\n    constructor(canvas){\n        this.#buttons = new (0, $35d204e98b857052$export$2e2bcd8739ae039)(canvas, this.#inputManager);\n        const word = (0, $2ce087bca3075e18$export$114aa43ee4755930)((0, $09b17a1eda282565$export$2e2bcd8739ae039));\n        this.#runLine.setWord(word);\n        this.#inventory.setShapes((0, $d8bf78f2b5ef2882$export$2e2bcd8739ae039)((0, $2a59e984b87de363$export$118f84f93f08b80c)(word)));\n        this.focusOn(this.#inventory);\n        this.#inventory.onRun = ()=>{\n            this.focusOn(this.#runLine);\n        };\n        this.#inventory.onSelection = (shape)=>{\n            this.#grid.cursorPos = {\n                x: Math.floor((0, $00387b554b88a86f$export$9188d4e069e95fa0) / 2),\n                y: Math.floor((0, $00387b554b88a86f$export$9188d4e069e95fa0) / 2)\n            };\n            this.#grid.selectShape(shape);\n            this.focusOn(this.#grid);\n        };\n        this.#inventory.onExit = (index)=>{\n            this.#grid.cursorPos = {\n                x: (0, $00387b554b88a86f$export$9188d4e069e95fa0) - 1,\n                y: index\n            };\n            this.focusOn(this.#grid);\n        };\n        this.#grid.onReturnShape = (shape)=>{\n            this.#inventory.addShape(shape);\n        };\n        this.#grid.onExit = (cursorPos)=>{\n            this.#inventory.cursorIndex = cursorPos.y;\n            this.focusOn(this.#inventory);\n        };\n        this.#runLine.onExit = ()=>{\n            this.focusOn(this.#inventory);\n        };\n    }\n    focusOn(ui) {\n        this.#focusedUI?.removeFocus();\n        this.#focusedUI = ui;\n        this.#inputManager.flush();\n        ui.giveFocus();\n        this.update(0);\n    }\n    update(delta) {\n        this.#focusedUI.update(this.#inputManager, delta);\n        this.#inputManager.flush();\n        this.#buttons.update();\n    }\n    #isLandscape() {\n        if (window.innerHeight < window.innerWidth) return true;\n        else return false;\n    }\n    render(canvas, ctx) {\n        if (this.#isLandscape()) canvas.height = (0, $00387b554b88a86f$export$a94a52152a1b6dd0);\n        else {\n            canvas.height = (0, $00387b554b88a86f$export$a94a52152a1b6dd0) * 2;\n            this.#buttons.render(ctx);\n        }\n        ctx.fillStyle = (0, $00387b554b88a86f$export$56d196d2844d1ca1).BOARD;\n        ctx.fillRect(0, 0, canvas.width, (0, $00387b554b88a86f$export$a94a52152a1b6dd0));\n        this.#grid.render(ctx);\n        this.#inventory.render(ctx);\n        this.#runLine.render(ctx);\n    }\n}\n\n\nconst $35da740d59af89ba$var$canvas = document.querySelector(\"canvas\");\nconst $35da740d59af89ba$var$ctx = $35da740d59af89ba$var$canvas.getContext(\"2d\");\nconst $35da740d59af89ba$var$game = new (0, $2fdd4cd8dcfa2293$export$2e2bcd8739ae039)($35da740d59af89ba$var$canvas);\nlet $35da740d59af89ba$var$previousTime;\nfunction $35da740d59af89ba$var$gameLoop(time) {\n    if ($35da740d59af89ba$var$previousTime == undefined) {\n        $35da740d59af89ba$var$previousTime = time;\n        requestAnimationFrame($35da740d59af89ba$var$gameLoop);\n        return;\n    }\n    const delta = (time - $35da740d59af89ba$var$previousTime) / 1000;\n    $35da740d59af89ba$var$previousTime = time;\n    $35da740d59af89ba$var$game.update(delta);\n    $35da740d59af89ba$var$game.render($35da740d59af89ba$var$canvas, $35da740d59af89ba$var$ctx);\n    requestAnimationFrame($35da740d59af89ba$var$gameLoop);\n}\nwindow.addEventListener(\"load\", function() {\n    $35da740d59af89ba$var$gameLoop(0);\n});\n\n\n//# sourceMappingURL=index.a8ac4073.js.map\n","import Game from \"./ui/game\";\n\nconst canvas = document.querySelector(\"canvas\");\nconst ctx = canvas.getContext(\"2d\");\nconst game = new Game(canvas);\n\nlet previousTime;\n\nfunction gameLoop(time) {\n  if (previousTime == undefined) {\n    previousTime = time;\n    requestAnimationFrame(gameLoop);\n    return;\n  }\n\n  const delta = (time - previousTime) / 1000;\n  previousTime = time;\n\n  game.update(delta);\n  game.render(canvas, ctx);\n\n  requestAnimationFrame(gameLoop);\n}\n\nwindow.addEventListener(\"load\", function () {\n  gameLoop(0);\n});\n","import Grid from \"./grid\";\nimport Inventory from \"./inventory\";\nimport RunLine from \"./run_line\";\nimport Buttons from \"./buttons\";\nimport { GRID_BLOCK_SIDE_LEN, GAME_HEIGHT, COLORS } from \"./shared_constants\";\nimport { InputManager } from \"../input_manager\";\nimport { randomItem } from \"../random\";\nimport { generateWordShapes } from \"../generation\";\nimport WORDS from \"../words\";\nimport arrayShuffle from \"array-shuffle\";\n\nexport default class Game {\n  #inventory = new Inventory();\n  #grid = new Grid();\n  #runLine = new RunLine(this.#grid);\n  #buttons;\n  #focusedUI = this.#inventory;\n  #inputManager = new InputManager();\n\n  constructor(canvas) {\n    this.#buttons = new Buttons(canvas, this.#inputManager);\n\n    const word = randomItem(WORDS);\n\n    this.#runLine.setWord(word);\n\n    this.#inventory.setShapes(arrayShuffle(generateWordShapes(word)));\n    this.focusOn(this.#inventory);\n\n    this.#inventory.onRun = () => {\n      this.focusOn(this.#runLine);\n    };\n\n    this.#inventory.onSelection = (shape) => {\n      this.#grid.cursorPos = {\n        x: Math.floor(GRID_BLOCK_SIDE_LEN / 2),\n        y: Math.floor(GRID_BLOCK_SIDE_LEN / 2),\n      };\n      this.#grid.selectShape(shape);\n      this.focusOn(this.#grid);\n    };\n\n    this.#inventory.onExit = (index) => {\n      this.#grid.cursorPos = {\n        x: GRID_BLOCK_SIDE_LEN - 1,\n        y: index,\n      };\n      this.focusOn(this.#grid);\n    };\n\n    this.#grid.onReturnShape = (shape) => {\n      this.#inventory.addShape(shape);\n    };\n\n    this.#grid.onExit = (cursorPos) => {\n      this.#inventory.cursorIndex = cursorPos.y;\n      this.focusOn(this.#inventory);\n    };\n\n    this.#runLine.onExit = () => {\n      this.focusOn(this.#inventory);\n    };\n  }\n\n  focusOn(ui) {\n    this.#focusedUI?.removeFocus();\n    this.#focusedUI = ui;\n\n    this.#inputManager.flush();\n    ui.giveFocus();\n    this.update(0);\n  }\n\n  update(delta) {\n    this.#focusedUI.update(this.#inputManager, delta);\n    this.#inputManager.flush();\n    this.#buttons.update();\n  }\n\n  #isLandscape() {\n    if (window.innerHeight < window.innerWidth) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  render(canvas, ctx) {\n    if (this.#isLandscape()) {\n      canvas.height = GAME_HEIGHT;\n    } else {\n      canvas.height = GAME_HEIGHT * 2;\n      this.#buttons.render(ctx);\n    }\n\n    ctx.fillStyle = COLORS.BOARD;\n    ctx.fillRect(0, 0, canvas.width, GAME_HEIGHT);\n\n    this.#grid.render(ctx);\n    this.#inventory.render(ctx);\n    this.#runLine.render(ctx);\n  }\n}\n","import { InputEnum } from \"../input_manager\";\nimport {\n  BLOCK_RENDER_SIDE_LEN,\n  GRID_BLOCK_SIDE_LEN,\n  GRID_RENDER_SIDE_LEN,\n  GRID_RENDER_OFFSET_X,\n  GRID_RENDER_OFFSET_Y,\n  COLORS,\n} from \"./shared_constants\";\n\nconst GRID_BORDER_SIZE = 6;\n\nexport default class Grid {\n  #hasFocus = false;\n  #focusedTime = 0;\n  #selectedShape = null;\n  #shapes = [];\n\n  cursorPos = {\n    x: 2,\n    y: 2,\n  };\n\n  onExit = () => {};\n  onReturnShape = (shape) => {};\n\n  setShapes(shapes) {\n    this.#shapes = shapes;\n  }\n\n  selectShape(shape) {\n    this.#selectedShape = shape;\n  }\n\n  #hasSameColorNeighbor(shape, x, y) {\n    const hasSameColor = (x, y) => {\n      const s = this.getShape(x, y);\n      return s && s != shape && s.color == shape.color;\n    };\n\n    return (\n      hasSameColor(x - 1, y) ||\n      hasSameColor(x + 1, y) ||\n      hasSameColor(x, y - 1) ||\n      hasSameColor(x, y + 1)\n    );\n  }\n\n  isValid() {\n    for (let y = 0; y < GRID_BLOCK_SIDE_LEN; y++) {\n      for (let x = 0; x < GRID_BLOCK_SIDE_LEN; x++) {\n        const shape = this.getShape(x, y);\n\n        if (!shape) continue;\n\n        if (this.#hasSameColorNeighbor(shape, x, y)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  #grabShape() {\n    const shape = this.getShape(this.cursorPos.x, this.cursorPos.y);\n\n    if (!shape) {\n      return null;\n    }\n\n    const index = this.#shapes.indexOf(shape);\n    this.#shapes.splice(index, 1);\n\n    this.#selectedShape = shape;\n    this.cursorPos.x = shape.x;\n    this.cursorPos.y = shape.y;\n\n    return shape;\n  }\n\n  #keepSelectedShapeInBounds() {\n    if (!this.#selectedShape) {\n      return;\n    }\n\n    let moved = false;\n\n    do {\n      for (let x = 0; x < GRID_BLOCK_SIDE_LEN; x++) {\n        if (this.#selectedShape.existsAt(x, -1)) {\n          this.#selectedShape.y += 1;\n        }\n\n        if (this.#selectedShape.existsAt(x, GRID_BLOCK_SIDE_LEN)) {\n          this.#selectedShape.y -= 1;\n        }\n      }\n\n      for (let y = 0; y < GRID_BLOCK_SIDE_LEN; y++) {\n        if (this.#selectedShape.existsAt(-1, y)) {\n          this.#selectedShape.x += 1;\n        }\n\n        if (this.#selectedShape.existsAt(GRID_BLOCK_SIDE_LEN, y)) {\n          this.#selectedShape.x -= 1;\n        }\n      }\n    } while (moved);\n\n    this.cursorPos.x = this.#selectedShape.x;\n    this.cursorPos.y = this.#selectedShape.y;\n  }\n\n  #placeSelectedShape() {\n    if (!this.#selectedShape) return false;\n\n    for (let x = 0; x < GRID_BLOCK_SIDE_LEN; x++) {\n      for (let y = 0; y < GRID_BLOCK_SIDE_LEN; y++) {\n        if (!this.#selectedShape.existsAt(x, y)) continue;\n\n        const shape = this.getShape(x, y);\n\n        if (shape) {\n          // todo: play sfx on fail?\n          return false;\n        }\n      }\n    }\n\n    this.#shapes.push(this.#selectedShape);\n    this.#selectedShape = null;\n    return true;\n  }\n\n  getShape(x, y) {\n    return this.#shapes.find((shape) => shape.existsAt(x, y));\n  }\n\n  giveFocus() {\n    this.#hasFocus = true;\n    this.#focusedTime = 0;\n  }\n\n  removeFocus() {\n    this.#hasFocus = false;\n  }\n\n  update(inputManager, delta) {\n    this.#focusedTime += delta;\n\n    const left =\n      inputManager.justPressed(InputEnum.LEFT) ||\n      inputManager.justRepeated(InputEnum.LEFT);\n    const right =\n      inputManager.justPressed(InputEnum.RIGHT) ||\n      inputManager.justRepeated(InputEnum.RIGHT);\n    const up =\n      inputManager.justPressed(InputEnum.UP) ||\n      inputManager.justRepeated(InputEnum.UP);\n    const down =\n      inputManager.justPressed(InputEnum.DOWN) ||\n      inputManager.justRepeated(InputEnum.DOWN);\n\n    if (left) {\n      this.cursorPos.x -= 1;\n    }\n    if (right) {\n      this.cursorPos.x += 1;\n    }\n    if (up) {\n      this.cursorPos.y -= 1;\n    }\n    if (down) {\n      this.cursorPos.y += 1;\n    }\n\n    if (!this.#selectedShape && this.cursorPos.x >= GRID_BLOCK_SIDE_LEN) {\n      this.onExit(this.cursorPos);\n    }\n\n    this.cursorPos.x = Math.max(0, this.cursorPos.x);\n    this.cursorPos.x = Math.min(GRID_BLOCK_SIDE_LEN - 1, this.cursorPos.x);\n    this.cursorPos.y = Math.max(0, this.cursorPos.y);\n    this.cursorPos.y = Math.min(GRID_BLOCK_SIDE_LEN - 1, this.cursorPos.y);\n\n    if (this.#selectedShape) {\n      this.#selectedShape.x = this.cursorPos.x;\n      this.#selectedShape.y = this.cursorPos.y;\n\n      if (inputManager.justPressed(InputEnum.L)) {\n        this.#selectedShape.rotateLeft();\n      }\n      if (inputManager.justPressed(InputEnum.R)) {\n        this.#selectedShape.rotate();\n      }\n\n      this.#keepSelectedShapeInBounds();\n\n      if (inputManager.justPressed(InputEnum.A)) {\n        this.#placeSelectedShape();\n      } else if (inputManager.justPressed(InputEnum.B)) {\n        const shape = this.#selectedShape;\n        this.#selectedShape = null;\n\n        this.#shapes = this.#shapes.filter((s) => s != shape);\n        this.onReturnShape(shape);\n      }\n    } else {\n      if (inputManager.justPressed(InputEnum.A)) {\n        this.#grabShape();\n      } else if (inputManager.justPressed(InputEnum.B)) {\n        this.onExit(this.cursorPos);\n      }\n    }\n  }\n\n  render(ctx) {\n    // border\n    ctx.fillStyle = COLORS.BORDER;\n    ctx.fillRect(\n      GRID_RENDER_OFFSET_X - GRID_BORDER_SIZE,\n      GRID_RENDER_OFFSET_Y - GRID_BORDER_SIZE,\n      GRID_RENDER_SIDE_LEN + GRID_BORDER_SIZE * 2,\n      GRID_RENDER_SIDE_LEN + GRID_BORDER_SIZE * 2\n    );\n\n    // background\n    ctx.fillStyle = COLORS.GRID_BACKGROUND;\n    ctx.fillRect(\n      GRID_RENDER_OFFSET_X,\n      GRID_RENDER_OFFSET_Y,\n      GRID_RENDER_SIDE_LEN,\n      GRID_RENDER_SIDE_LEN\n    );\n\n    // blocks\n    for (let x = 0; x < GRID_BLOCK_SIDE_LEN; x++) {\n      for (let y = 0; y < GRID_BLOCK_SIDE_LEN; y++) {\n        const shape = this.getShape(x, y);\n\n        if (shape) {\n          ctx.fillStyle = shape.color;\n          ctx.fillRect(\n            GRID_RENDER_OFFSET_X + BLOCK_RENDER_SIDE_LEN * x,\n            GRID_RENDER_OFFSET_Y + BLOCK_RENDER_SIDE_LEN * y,\n            BLOCK_RENDER_SIDE_LEN,\n            BLOCK_RENDER_SIDE_LEN\n          );\n        }\n\n        if (this.#selectedShape && this.#selectedShape.existsAt(x, y)) {\n          ctx.globalAlpha = 0.75;\n          ctx.fillStyle = this.#selectedShape.color;\n          ctx.fillRect(\n            GRID_RENDER_OFFSET_X + BLOCK_RENDER_SIDE_LEN * x,\n            GRID_RENDER_OFFSET_Y + BLOCK_RENDER_SIDE_LEN * y,\n            BLOCK_RENDER_SIDE_LEN,\n            BLOCK_RENDER_SIDE_LEN\n          );\n\n          ctx.globalAlpha = 1;\n        }\n      }\n    }\n\n    ctx.fillStyle = COLORS.LINE_SHADOW;\n    ctx.beginPath();\n    // to the right\n    ctx.moveTo(\n      GRID_RENDER_OFFSET_X,\n      GRID_RENDER_OFFSET_Y + BLOCK_RENDER_SIDE_LEN * 2\n    );\n    ctx.lineTo(\n      GRID_RENDER_OFFSET_X + GRID_RENDER_SIDE_LEN,\n      GRID_RENDER_OFFSET_Y + BLOCK_RENDER_SIDE_LEN * 2\n    );\n\n    // center\n    ctx.lineTo(\n      GRID_RENDER_OFFSET_X + GRID_RENDER_SIDE_LEN,\n      GRID_RENDER_OFFSET_Y + BLOCK_RENDER_SIDE_LEN * 2.5\n    );\n\n    // back to the left\n    ctx.lineTo(\n      GRID_RENDER_OFFSET_X + GRID_RENDER_SIDE_LEN,\n      GRID_RENDER_OFFSET_Y + BLOCK_RENDER_SIDE_LEN * 3\n    );\n    ctx.lineTo(\n      GRID_RENDER_OFFSET_X,\n      GRID_RENDER_OFFSET_Y + BLOCK_RENDER_SIDE_LEN * 3\n    );\n\n    // auto closes\n    ctx.fill();\n\n    // draw cursor\n    if (this.#hasFocus) {\n      const { x, y } = this.cursorPos;\n      ctx.strokeStyle = COLORS.GRID_CURSOR;\n\n      ctx.strokeRect(\n        GRID_RENDER_OFFSET_X + BLOCK_RENDER_SIDE_LEN * x + 0.5,\n        GRID_RENDER_OFFSET_Y + BLOCK_RENDER_SIDE_LEN * y + 0.5,\n        BLOCK_RENDER_SIDE_LEN - 1,\n        BLOCK_RENDER_SIDE_LEN - 1\n      );\n\n      // draw shape letter\n      const shape = this.getShape(x, y);\n\n      if (!this.#selectedShape && shape) {\n        ctx.fillStyle = COLORS.GRID_CURSOR_LETTER;\n        ctx.font = \"16px bn6-bold\";\n        ctx.textBaseline = \"top\";\n        ctx.fillText(\n          shape.letter,\n          GRID_RENDER_OFFSET_X + BLOCK_RENDER_SIDE_LEN * x + 6,\n          GRID_RENDER_OFFSET_Y + BLOCK_RENDER_SIDE_LEN * y + 3\n        );\n      }\n    }\n  }\n}\n","export const InputEnum = {\n  UP: 0,\n  DOWN: 1,\n  LEFT: 2,\n  RIGHT: 3,\n  A: 4,\n  B: 5,\n  START: 6,\n  L: 7,\n  R: 8,\n  SIZE: 9,\n};\n\nconst KeyboardBinding = {\n  ArrowUp: InputEnum.UP,\n  ArrowDown: InputEnum.DOWN,\n  ArrowLeft: InputEnum.LEFT,\n  ArrowRight: InputEnum.RIGHT,\n  KeyZ: InputEnum.A,\n  KeyX: InputEnum.B,\n  Enter: InputEnum.START,\n  KeyA: InputEnum.L,\n  KeyS: InputEnum.R,\n};\n\nexport class InputManager {\n  #pressed = [];\n  #repeated = [];\n  #held = [];\n  #released = [];\n\n  constructor() {\n    document.addEventListener(\"keydown\", (e) => {\n      const input = KeyboardBinding[e.code];\n\n      if (input != undefined) {\n        this.simulateRepeat(input);\n        this.simulatePress(input);\n      }\n    });\n\n    document.addEventListener(\"keyup\", (e) => {\n      const input = KeyboardBinding[e.code];\n\n      if (input != undefined) {\n        this.simulateRelease(input);\n      }\n    });\n  }\n\n  simulatePress(input) {\n    if (!this.#held[input]) {\n      this.#pressed[input] = true;\n      this.#held[input] = true;\n    }\n  }\n\n  simulateRepeat(input) {\n    // todo, handle using counters\n    if (this.#held[input]) {\n      this.#repeated[input] = true;\n    }\n  }\n\n  simulateRelease(input) {\n    if (input != undefined && this.#held[input]) {\n      this.#released[input] = true;\n      this.#held[input] = false;\n    }\n  }\n\n  justPressed(input) {\n    return this.#pressed[input] == true;\n  }\n\n  justRepeated(input) {\n    return this.#repeated[input] == true;\n  }\n\n  justReleased(input) {\n    return this.#released[input] == true;\n  }\n\n  isDown(input) {\n    return this.#held[input] == true;\n  }\n\n  flush() {\n    this.#pressed = [];\n    this.#released = [];\n    this.#repeated = [];\n  }\n}\n","export const GAME_WIDTH = 240;\nexport const GAME_HEIGHT = 160;\n\nexport const BLOCK_RENDER_SIDE_LEN = 20;\n\nexport const GRID_BLOCK_SIDE_LEN = 5;\nexport const GRID_BLOCK_CENTER = Math.floor(GRID_BLOCK_SIDE_LEN / 2);\nexport const GRID_RENDER_SIDE_LEN = GRID_BLOCK_SIDE_LEN * BLOCK_RENDER_SIDE_LEN;\nexport const GRID_RENDER_OFFSET_X = BLOCK_RENDER_SIDE_LEN;\nexport const GRID_RENDER_OFFSET_Y = BLOCK_RENDER_SIDE_LEN * 1.5;\n\nexport const INVENTORY_OFFSET_X =\n  GRID_RENDER_OFFSET_X + GRID_RENDER_SIDE_LEN + BLOCK_RENDER_SIDE_LEN;\nexport const INVENTORY_OFFSET_Y = GRID_RENDER_OFFSET_Y;\n\nexport const COLORS = {\n  // shared\n  BOARD: \"darkorange\",\n  BORDER: \"#889EB3\",\n  // grid\n  GRID_BACKGROUND: \"#124D7F\",\n  GRID_CURSOR: \"lime\",\n  GRID_CURSOR_LETTER: \"#0006\",\n  LINE_SHADOW: \"#00000033\",\n  // line\n  PROCESSING_LETTER: \"WHITE\",\n  CORRECT_LETTER: \"lime\",\n  INCORRECT_LETTER: \"red\",\n  INVALID_LETTER: \"orange\",\n  // inventory\n  INVENTORY_CURSOR_BORDER: \"green\",\n  INVENTORY_CURSOR: \"lime\",\n};\n","import {\n  INVENTORY_OFFSET_X,\n  INVENTORY_OFFSET_Y,\n  BLOCK_RENDER_SIDE_LEN,\n  GRID_BLOCK_SIDE_LEN,\n  COLORS,\n} from \"./shared_constants\";\nimport { InputEnum } from \"../input_manager\";\nimport { randomInt } from \"../random\";\n\nexport default class Inventory {\n  #hasFocus = false;\n  #focusTime = 0;\n  #shapes = [];\n\n  cursorIndex = 0;\n  onRun = () => {};\n  onExit = (gridPos) => {};\n  onSelection = (shape) => {};\n\n  giveFocus() {\n    this.#hasFocus = true;\n    this.#focusTime = 0;\n  }\n\n  removeFocus() {\n    this.#hasFocus = false;\n    this.#focusTime = 0;\n  }\n\n  setShapes(shapes) {\n    shapes.forEach((shape) => {\n      shape.x = Math.floor(GRID_BLOCK_SIDE_LEN / 2);\n      shape.y = Math.floor(GRID_BLOCK_SIDE_LEN / 2);\n      shape.rotation = randomInt(4);\n    });\n\n    this.#shapes = shapes;\n  }\n\n  addShape(shape) {\n    shape.x = Math.floor(GRID_BLOCK_SIDE_LEN / 2);\n    shape.y = Math.floor(GRID_BLOCK_SIDE_LEN / 2);\n    this.#shapes.push(shape);\n  }\n\n  update(inputManager, delta) {\n    this.#focusTime += delta;\n\n    if (inputManager.justPressed(InputEnum.LEFT)) {\n      this.onExit(this.cursorIndex);\n      return;\n    }\n\n    const pressedUp =\n      inputManager.justPressed(InputEnum.UP) ||\n      inputManager.justRepeated(InputEnum.UP);\n\n    const pressedDown =\n      inputManager.justPressed(InputEnum.DOWN) ||\n      inputManager.justRepeated(InputEnum.DOWN);\n\n    if (pressedUp) {\n      this.cursorIndex -= 1;\n    }\n    if (pressedDown) {\n      this.cursorIndex += 1;\n    }\n\n    this.cursorIndex = Math.max(0, this.cursorIndex);\n    this.cursorIndex = Math.min(this.#shapes.length, this.cursorIndex);\n\n    if (inputManager.justPressed(InputEnum.A)) {\n      if (this.cursorIndex < this.#shapes.length) {\n        const [removedShape] = this.#shapes.splice(this.cursorIndex, 1);\n        this.onSelection(removedShape);\n      } else {\n        this.onRun();\n      }\n    }\n  }\n\n  render(ctx) {\n    ctx.font = \"16px bn6-bold\";\n    ctx.textBaseline = \"top\";\n    const width = 26;\n    const height = 15;\n\n    for (let i = 0; i < this.#shapes.length; i++) {\n      const shape = this.#shapes[i];\n\n      const startX = INVENTORY_OFFSET_X;\n      const startY = INVENTORY_OFFSET_Y + BLOCK_RENDER_SIDE_LEN * i;\n\n      // render border\n      ctx.fillStyle = COLORS.BORDER;\n      ctx.fillRect(startX - 2, startY - 2, width + 4, height + 4);\n\n      // render bg\n      ctx.fillStyle = COLORS.GRID_BACKGROUND;\n      ctx.fillRect(startX, startY, width, height);\n\n      // render mini shape\n      ctx.fillStyle = shape.color;\n      for (let x = 0; x < 5; x++) {\n        for (let y = 0; y < 5; y++) {\n          if (!shape.existsAt(x, y)) continue;\n\n          ctx.fillRect(startX + x * 3 + 11, startY + y * 3, 3, 3);\n        }\n      }\n\n      ctx.fillStyle = \"white\";\n      ctx.fillText(shape.letter, startX + 1, startY + 1);\n    }\n\n    // render run button\n    {\n      const startX = INVENTORY_OFFSET_X;\n      const startY =\n        INVENTORY_OFFSET_Y + BLOCK_RENDER_SIDE_LEN * this.#shapes.length;\n\n      // render border\n      ctx.fillStyle = COLORS.BORDER;\n      ctx.fillRect(startX - 2, startY - 2, width + 4, height + 4);\n\n      // render bg\n      ctx.fillStyle = \"lime\";\n      ctx.fillRect(startX, startY, width, height);\n\n      ctx.fillStyle = \"white\";\n      ctx.fillText(\"RUN\", startX + 1, startY + 1);\n    }\n\n    if (this.#hasFocus) {\n      const startX = INVENTORY_OFFSET_X - 9 + Math.sin(this.#focusTime * 16);\n      const startY =\n        INVENTORY_OFFSET_Y + BLOCK_RENDER_SIDE_LEN * this.cursorIndex;\n\n      ctx.strokeStyle = COLORS.INVENTORY_CURSOR_BORDER;\n      ctx.fillStyle = COLORS.INVENTORY_CURSOR;\n      ctx.beginPath();\n      ctx.moveTo(startX, startY);\n      ctx.lineTo(startX + 8, startY + height / 2);\n      ctx.lineTo(startX, startY + height);\n      ctx.closePath();\n      ctx.fill();\n      ctx.stroke();\n    }\n  }\n}\n","// [0, n)\nexport function randomInt(n) {\n  return Math.floor(Math.random() * n);\n}\n\nexport function randomItem(array) {\n  return array[randomInt(array.length)];\n}\n","import { InputEnum } from \"../input_manager\";\nimport {\n  BLOCK_RENDER_SIDE_LEN,\n  GRID_RENDER_SIDE_LEN,\n  GRID_RENDER_OFFSET_X,\n  GRID_RENDER_OFFSET_Y,\n  GRID_BLOCK_SIDE_LEN,\n  GRID_BLOCK_CENTER,\n  COLORS,\n} from \"./shared_constants\";\n\nexport default class RunLine {\n  #progress = 0;\n  #grid;\n  #word;\n  #builtWord;\n  #validGrid;\n\n  constructor(grid, word) {\n    this.#grid = grid;\n  }\n\n  onSuccess = () => {};\n  onExit = () => {};\n\n  setWord(word) {\n    this.#word = word;\n  }\n\n  giveFocus() {\n    this.#progress = 0;\n    this.#builtWord = null;\n  }\n\n  removeFocus() {\n    this.#progress = 0;\n  }\n\n  #reviewGrid() {\n    this.#builtWord = \"\";\n\n    for (let i = 0; i < GRID_BLOCK_SIDE_LEN; i++) {\n      const shape = this.#grid.getShape(i, GRID_BLOCK_CENTER);\n\n      this.#builtWord += shape ? shape.letter : \"?\";\n    }\n\n    this.#validGrid = this.#grid.isValid();\n  }\n\n  update(inputManager, delta) {\n    this.#progress = Math.min(1, this.#progress + delta / 2);\n\n    const accept = inputManager.justPressed(InputEnum.A);\n    const cancel = inputManager.justPressed(InputEnum.B);\n\n    if ((accept || cancel) && this.#progress == 1) {\n      this.onExit();\n    }\n\n    if (!this.#builtWord && this.#progress == 1) {\n      this.#reviewGrid();\n    }\n  }\n\n  #renderLine(ctx) {\n    ctx.beginPath();\n\n    const progressWidth = GRID_RENDER_SIDE_LEN * this.#progress;\n\n    // to the right\n    ctx.moveTo(\n      GRID_RENDER_OFFSET_X,\n      GRID_RENDER_OFFSET_Y + BLOCK_RENDER_SIDE_LEN * 2\n    );\n    ctx.lineTo(\n      GRID_RENDER_OFFSET_X + progressWidth,\n      GRID_RENDER_OFFSET_Y + BLOCK_RENDER_SIDE_LEN * 2\n    );\n\n    // center\n    ctx.lineTo(\n      GRID_RENDER_OFFSET_X + progressWidth,\n      GRID_RENDER_OFFSET_Y + BLOCK_RENDER_SIDE_LEN * 2.5\n    );\n\n    // back to the left\n    ctx.lineTo(\n      GRID_RENDER_OFFSET_X + progressWidth,\n      GRID_RENDER_OFFSET_Y + BLOCK_RENDER_SIDE_LEN * 3\n    );\n    ctx.lineTo(\n      GRID_RENDER_OFFSET_X,\n      GRID_RENDER_OFFSET_Y + BLOCK_RENDER_SIDE_LEN * 3\n    );\n\n    ctx.fill();\n  }\n\n  #renderText(ctx, offsetX, offsetY) {\n    for (let i = 0; i < GRID_BLOCK_SIDE_LEN * this.#progress - 0.5; i++) {\n      const shape = this.#grid.getShape(i, GRID_BLOCK_CENTER);\n\n      ctx.font = \"16px bn6-bold\";\n      ctx.fillText(\n        shape ? shape.letter : \"?\",\n        GRID_RENDER_OFFSET_X + BLOCK_RENDER_SIDE_LEN * i + 6 + offsetX,\n        GRID_RENDER_OFFSET_Y +\n          BLOCK_RENDER_SIDE_LEN * GRID_BLOCK_CENTER +\n          3 +\n          offsetY\n      );\n    }\n  }\n\n  render(ctx) {\n    ctx.fillStyle = \"#ffff0066\";\n\n    this.#renderLine(ctx);\n\n    let text_color;\n    if (this.#progress < 1) {\n      text_color = COLORS.PROCESSING_LETTER;\n    } else if (this.#builtWord == this.#word) {\n      text_color = this.#validGrid\n        ? COLORS.CORRECT_LETTER\n        : COLORS.INVALID_LETTER;\n    } else {\n      text_color = COLORS.INCORRECT_LETTER;\n    }\n\n    // text shadow\n    ctx.fillStyle = text_color;\n    ctx.globalAlpha = 0.5;\n    this.#renderText(ctx, 1, 1);\n\n    // darken shadow\n    ctx.fillStyle = \"black\";\n    ctx.globalAlpha = 0.5;\n    this.#renderText(ctx, 1, 1);\n\n    // draw text\n    ctx.globalAlpha = 1;\n    ctx.fillStyle = text_color;\n    this.#renderText(ctx, 0, 0);\n  }\n}\n","import { GAME_WIDTH, GAME_HEIGHT } from \"./shared_constants\";\nimport { InputEnum } from \"../input_manager\";\n\nconst BUTTON_SIZE = 24;\n\nexport default class Buttons {\n  #buttons = [\n    {\n      binding: InputEnum.L,\n      x: 0,\n      y: 1,\n      w: 2,\n      h: 1,\n    },\n    {\n      binding: InputEnum.R,\n      x: GAME_WIDTH / BUTTON_SIZE - 2,\n      y: 1,\n      w: 2,\n      h: 1,\n    },\n    {\n      binding: InputEnum.LEFT,\n      x: 1,\n      y: 4,\n      w: 1,\n      h: 1,\n    },\n    {\n      binding: InputEnum.RIGHT,\n      x: 3,\n      y: 4,\n      w: 1,\n      h: 1,\n    },\n    {\n      binding: InputEnum.UP,\n      x: 2,\n      y: 3,\n      w: 1,\n      h: 1,\n    },\n    {\n      binding: InputEnum.DOWN,\n      x: 2,\n      y: 5,\n      w: 1,\n      h: 1,\n    },\n    {\n      binding: InputEnum.A,\n      x: GAME_WIDTH / BUTTON_SIZE - 3,\n      y: 3,\n      w: 1,\n      h: 1,\n    },\n    {\n      binding: InputEnum.B,\n      x: GAME_WIDTH / BUTTON_SIZE - 4,\n      y: 4,\n      w: 1,\n      h: 1,\n    },\n  ];\n  #canvas;\n  #state = [];\n  #inputManager;\n\n  constructor(canvas, inputManager) {\n    this.#canvas = canvas;\n    this.#inputManager = inputManager;\n\n    canvas.addEventListener(\"touchstart\", (e) => {\n      this.#updateFromTouchEvent(e);\n    });\n\n    canvas.addEventListener(\"touchmove\", (e) => {\n      this.#updateFromTouchEvent(e);\n    });\n\n    canvas.addEventListener(\"touchend\", (e) => {\n      this.#updateFromTouchEvent(e);\n    });\n  }\n\n  #updateFromTouchEvent(event) {\n    const canvas = this.#canvas;\n    const canvasRect = canvas.getBoundingClientRect();\n\n    const newState = [];\n\n    for (const touch of event.targetTouches) {\n      // get corrected canvas position\n      let x =\n        ((touch.clientX - canvasRect.x) / canvasRect.width) * canvas.width;\n      let y =\n        ((touch.clientY - canvasRect.y) / canvasRect.height) * canvas.height;\n\n      // transform position to button space\n      x = x / BUTTON_SIZE;\n      y = (y - GAME_HEIGHT) / BUTTON_SIZE;\n\n      for (const button of this.#buttons) {\n        if (\n          x > button.x &&\n          y > button.y &&\n          x < button.x + button.w &&\n          y < button.y + button.h\n        ) {\n          newState[button.binding] = true;\n        }\n      }\n    }\n\n    for (let i = 0; i < InputEnum.SIZE; i++) {\n      if (this.#state[i] && !newState[i]) {\n        this.#inputManager.simulateRelease(i);\n      } else if (!this.#state[i] && newState[i]) {\n        this.#inputManager.simulatePress(i);\n      }\n    }\n\n    this.#state = newState;\n  }\n\n  update() {\n    for (let i = 0; i < InputEnum.SIZE; i++) {\n      if (this.#state[i]) {\n        this.#inputManager.simulatePress(i);\n      }\n    }\n  }\n\n  render(ctx) {\n    ctx.fillStyle = \"white\";\n\n    for (const button of this.#buttons) {\n      ctx.fillRect(\n        button.x * BUTTON_SIZE,\n        GAME_HEIGHT + button.y * BUTTON_SIZE,\n        button.w * BUTTON_SIZE,\n        button.h * BUTTON_SIZE\n      );\n    }\n  }\n}\n","import Shape from \"./shape\";\nimport { randomInt, randomItem } from \"./random\";\n\nconst GRID_SIDE_LEN = 5;\nlet COLORS = [\"#DE1100\", \"#D688C0\", \"#2880D9\", \"#19C000\", \"#D8DA00\", \"#D8D8D8\"];\nconst MAX_SHAPE_SIZE = 4;\nconst MAX_COLORS = 4;\n\nfunction generateColors() {\n  const colors = [];\n\n  while (colors.length < MAX_COLORS) {\n    const color = randomItem(COLORS);\n\n    if (!colors.includes(color)) {\n      colors.push(color);\n    }\n  }\n\n  return colors;\n}\n\nfunction internalGenerateWordShapes(word) {\n  let shapes = [];\n  let nextRun = [];\n  let colors = generateColors();\n  let colorOffset = randomInt(colors.length);\n\n  for (let i = 0; i < GRID_SIDE_LEN; i++) {\n    const shape = new Shape();\n    shape.color = colors[(i + colorOffset) % colors.length];\n    shape.x = i;\n    shape.y = 2;\n    shape.letter = word[i];\n\n    shape.set(shape.x, shape.y, true);\n    shapes.push(shape);\n\n    nextRun.push({\n      shape,\n      x: shape.x,\n      y: shape.y - 1,\n    });\n\n    nextRun.push({\n      shape,\n      x: shape.x,\n      y: shape.y + 1,\n    });\n\n    if (word[i] == word[i + 1]) {\n      // merge repeated letter\n      shape.set(shape.x + 1, shape.y, true);\n      i++;\n\n      nextRun.push({\n        shape,\n        x: shape.x + 1,\n        y: shape.y - 1,\n      });\n\n      nextRun.push({\n        shape,\n        x: shape.x + 1,\n        y: shape.y + 1,\n      });\n    }\n  }\n\n  const spread = ({ shape, x, y }) => {\n    nextRun.push({\n      shape: shape,\n      x: x - 1,\n      y: y,\n    });\n\n    nextRun.push({\n      shape: shape,\n      x: x + 1,\n      y: y,\n    });\n\n    nextRun.push({\n      shape: shape,\n      x: x,\n      y: y - 1,\n    });\n\n    nextRun.push({\n      shape: shape,\n      x: x,\n      y: y + 1,\n    });\n  };\n\n  function hasSameColorNeighbor(shape, x, y) {\n    function hasSameColor(x, y) {\n      const s = shapes.find((shape) => shape.existsAt(x, y));\n      return s && s != shape && s.color == shape.color;\n    }\n\n    return (\n      hasSameColor(x - 1, y) ||\n      hasSameColor(x + 1, y) ||\n      hasSameColor(x, y - 1) ||\n      hasSameColor(x, y + 1)\n    );\n  }\n\n  while (nextRun.length > 0) {\n    const run = nextRun;\n    nextRun = [];\n\n    for (const { shape, x, y } of run) {\n      if (x < 0 || y < 0 || x >= GRID_SIDE_LEN || y >= GRID_SIDE_LEN) {\n        continue;\n      }\n\n      const otherShape = shapes.find((shape) => shape.existsAt(x, y));\n\n      if (otherShape) continue;\n\n      const growShape = () => {\n        // spread if we can, or drop this search\n\n        if (hasSameColorNeighbor(shape, x, y)) {\n          return;\n        }\n\n        if (shape.countBlocks() >= MAX_SHAPE_SIZE || !shape.canSet(x, y)) {\n          return;\n        }\n\n        shape.set(x, y, true);\n        spread({ shape, x, y });\n      };\n\n      const tryLater = () => {\n        // do nothing, but try again next run\n        nextRun.push({ shape, x, y });\n      };\n\n      const options = [growShape, tryLater];\n\n      randomItem(options)();\n    }\n  }\n\n  return shapes;\n}\n\nexport function generateWordShapes(word) {\n  let shapes;\n\n  do {\n    shapes = internalGenerateWordShapes(word);\n  } while (shapes.filter((shape) => shape.isColumn()).length > 1);\n\n  for (const shape of shapes) {\n    shape.recalculateCenter();\n  }\n\n  return shapes;\n}\n\nexport function generateFillerShapes(word) {\n  let shapes;\n\n  do {\n    shapes = internalGenerateWordShapes(word);\n  } while (shapes.filter((shape) => shape.isColumn()).length > 1);\n\n  return shapes;\n}\n","const MAX_SHAPE_SIDE_LEN = 5;\nconst CENTER_LEN = Math.floor(MAX_SHAPE_SIDE_LEN / 2);\n\nexport default class Shape {\n  #blocks = [];\n\n  constructor() {\n    this.color = \"\";\n    this.letter = \"\";\n    this.x = 0;\n    this.y = 0;\n    this.rotation = 0;\n\n    for (let i = 0; i < MAX_SHAPE_SIDE_LEN * MAX_SHAPE_SIDE_LEN; i++) {\n      this.#blocks[i] = false;\n    }\n  }\n\n  isColumn() {\n    let count = 0;\n\n    for (let i = 0; i < MAX_SHAPE_SIDE_LEN; i++) {\n      for (let j = 0; j < MAX_SHAPE_SIDE_LEN; j++) {\n        const index = i * MAX_SHAPE_SIDE_LEN + j;\n\n        if (!this.#blocks[index]) continue;\n\n        if (j != CENTER_LEN) {\n          // found a block outside of a column\n          return false;\n        }\n\n        count++;\n      }\n    }\n\n    // 1x1 is not a column\n    return count > 1;\n  }\n\n  rotate() {\n    this.rotation += 1;\n    this.rotation %= 4;\n  }\n\n  rotateLeft() {\n    this.rotation -= 1;\n\n    if (this.rotation < 0) {\n      this.rotation = 3;\n    }\n  }\n\n  canSet(x, y) {\n    const index = this.getIndex(x, y);\n    return index >= 0 && index < MAX_SHAPE_SIDE_LEN * MAX_SHAPE_SIDE_LEN;\n  }\n\n  set(x, y, value) {\n    const index = this.getIndex(x, y);\n    this.#blocks[index] = value;\n  }\n\n  existsAt(x, y) {\n    const index = this.getIndex(x, y);\n    return this.#blocks[index] == true;\n  }\n\n  countBlocks() {\n    let count = 0;\n\n    for (let i = 0; i < this.#blocks.length; i++) {\n      if (this.#blocks[i]) {\n        count++;\n      }\n    }\n\n    return count;\n  }\n\n  recalculateCenter() {\n    const bounds = {\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n    };\n\n    const validPositions = [];\n\n    for (let i = 0; i < MAX_SHAPE_SIDE_LEN; i++) {\n      for (let j = 0; j < MAX_SHAPE_SIDE_LEN; j++) {\n        const index = i * MAX_SHAPE_SIDE_LEN + j;\n\n        if (!this.#blocks[index]) continue;\n\n        const x = j - CENTER_LEN;\n        const y = i - CENTER_LEN;\n\n        if (x < bounds.left) {\n          bounds.left = x;\n        }\n        if (y < bounds.top) {\n          bounds.top = y;\n        }\n        if (x > bounds.right) {\n          bounds.right = x;\n        }\n        if (y > bounds.bottom) {\n          bounds.bottom = y;\n        }\n\n        validPositions.push({ x, y });\n      }\n    }\n\n    const trueCenter = {\n      x: (bounds.left + bounds.right) / 2,\n      y: (bounds.bottom + bounds.top) / 2,\n    };\n\n    validPositions.sort((posA, posB) => {\n      const manhattanDistA =\n        Math.abs(trueCenter.x - posA.x) + Math.abs(trueCenter.y - posA.y);\n      const manhattanDistB =\n        Math.abs(trueCenter.x - posB.x) + Math.abs(trueCenter.y - posB.y);\n\n      return manhattanDistA < manhattanDistB ? -1 : 1;\n    });\n\n    const newCenter = validPositions[0];\n    this.x -= newCenter.x;\n    this.y -= newCenter.y;\n\n    const updatedBlocks = [...this.#blocks];\n\n    for (let i = 0; i < MAX_SHAPE_SIDE_LEN; i++) {\n      for (let j = 0; j < MAX_SHAPE_SIDE_LEN; j++) {\n        let value = false;\n\n        const oldX = j + newCenter.x;\n        const oldY = i + newCenter.y;\n\n        if (\n          oldX >= 0 &&\n          oldY >= 0 &&\n          oldX < MAX_SHAPE_SIDE_LEN &&\n          oldY < MAX_SHAPE_SIDE_LEN\n        ) {\n          const index = oldY * MAX_SHAPE_SIDE_LEN + oldX;\n          value = this.#blocks[index];\n        }\n\n        const index = i * MAX_SHAPE_SIDE_LEN + j;\n        updatedBlocks[index] = value;\n      }\n    }\n\n    this.#blocks = updatedBlocks;\n  }\n\n  getIndex(x, y) {\n    x = x - this.x;\n    y = y - this.y;\n    let transformedX, transformedY;\n\n    switch (this.rotation) {\n      case 0:\n        // [x-y-, x+y-]\n        // [x-y+, x+y+]\n        transformedX = x;\n        transformedY = y;\n        break;\n      case 1:\n        // 90 clockwise\n        // [x-y+, x-y-]\n        // [x+y+, x+y-]\n        transformedX = y;\n        transformedY = CENTER_LEN - x - 2;\n        break;\n      case 2:\n        // 180\n        // [x+y+, x-y+]\n        // [x+y-, x-y-]\n        transformedX = CENTER_LEN - x - 2;\n        transformedY = CENTER_LEN - y - 2;\n        break;\n      case 3:\n        // 270\n        // [x+y-, x+y+]\n        // [x-y-, x-y+]\n        transformedX = CENTER_LEN - y - 2;\n        transformedY = x;\n        break;\n    }\n\n    transformedX += CENTER_LEN;\n    transformedY += CENTER_LEN;\n\n    if (\n      transformedX < 0 ||\n      transformedY < 0 ||\n      transformedX >= MAX_SHAPE_SIDE_LEN ||\n      transformedY >= MAX_SHAPE_SIDE_LEN\n    ) {\n      return -1;\n    }\n\n    return transformedY * MAX_SHAPE_SIDE_LEN + transformedX;\n  }\n}\n","export default [\n  // misc\n  \"ZENNY\",\n  \"CHIPS\",\n  \"CYBER\",\n  \"PANEL\",\n  \"COLOR\",\n  \"POINT\",\n  \"GAUGE\",\n  \"VIRUS\",\n  \"DRILL\",\n  \"SNEAK\",\n  \"HPMEM\",\n  \"BREAK\",\n  // NCP\n  \"SHOES\",\n  \"HUMOR\",\n  \"TANGO\",\n  \"ARMOR\",\n  \"BLOCK\",\n  // humans\n  \"CHAUD\",\n  \"BARYL\",\n  // navis\n  \"GLIDE\",\n  \"PROTO\",\n  // \"NUMBR\", // NumbrMan Chips + NumberMan\n  \"MAGIC\",\n  \"SKULL\",\n  \"SHARK\",\n  \"PHARO\",\n  // \"SHADO\",\n  // \"MAGNT\",\n  // \"NAPLM\",\n  \"METAL\",\n  \"JAPAN\",\n  // \"BUBBL\",\n  \"SPARK\",\n  \"VIDEO\",\n  \"SHADE\",\n  \"COSMO\",\n  \"MEDDY\",\n  \"CHAOS\",\n  \"SPOUT\",\n  \"BLAST\",\n  \"JUDGE\",\n  \"ERASE\",\n  \"TENGU\",\n  \"BEAST\",\n  \"CACHE\",\n  \"KENDO\",\n  \"LASER\",\n  \"QUICK\",\n  \"STONE\",\n  // chips\n  \"STEAL\",\n  \"CLOUD\",\n  \"INVIS\",\n  \"POPUP\",\n  \"SWORD\",\n  \"BLADE\",\n  \"PUNCH\",\n  \"LANCE\",\n  \"GUARD\",\n  \"RECOV\",\n  \"ARROW\",\n  \"SPICE\",\n  \"SHAKE\",\n  \"PANIC\",\n  \"BATCH\",\n  \"SNAKE\",\n  \"QUAKE\",\n  \"DELTA\",\n  \"STAGE\",\n  // viruses\n  \"BILLY\",\n  \"FISHY\",\n  \"RATTY\",\n  \"PUFFY\",\n  \"JELLY\",\n  \"BUNNY\",\n  \"POWIE\",\n  \"PENGI\",\n  \"VINEY\",\n  \"ALPHA\",\n  \"TOTEM\",\n  \"TWINS\",\n  \"KILBY\",\n  \"WALLA\",\n  \"BATTY\",\n  \"HANDI\",\n  \"ZOMON\",\n  \"BRUTE\",\n  \"HEADY\",\n  \"GOLEM\",\n];\n","export default function arrayShuffle(array) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new TypeError(`Expected an array, got ${typeof array}`);\n\t}\n\n\tarray = [...array];\n\n\tfor (let index = array.length - 1; index > 0; index--) {\n\t\tconst newIndex = Math.floor(Math.random() * (index + 1));\n\t\t[array[index], array[newIndex]] = [array[newIndex], array[index]];\n\t}\n\n\treturn array;\n}\n"],"names":["$35da740d59af89ba$var$previousTime","$f8e847403f6cae58$export$17d7fd322af6b968","UP","DOWN","LEFT","RIGHT","A","B","START","L","R","SIZE","$f8e847403f6cae58$var$KeyboardBinding","ArrowUp","ArrowDown","ArrowLeft","ArrowRight","KeyZ","KeyX","Enter","KeyA","KeyS","$f8e847403f6cae58$export$2da2653229140a6c","constructor","document","addEventListener","e","input","code","undefined","simulateRepeat","simulatePress","simulateRelease","justPressed","justRepeated","justReleased","isDown","flush","$00387b554b88a86f$export$d1ce89bfcf9b1ff3","Math","floor","$00387b554b88a86f$export$9188d4e069e95fa0","$00387b554b88a86f$export$56d196d2844d1ca1","BOARD","BORDER","GRID_BACKGROUND","GRID_CURSOR","GRID_CURSOR_LETTER","LINE_SHADOW","PROCESSING_LETTER","CORRECT_LETTER","INCORRECT_LETTER","INVALID_LETTER","INVENTORY_CURSOR_BORDER","INVENTORY_CURSOR","$30e9a94c591cfedc$export$2e2bcd8739ae039","cursorPos","x","y","onExit","onReturnShape","shape","setShapes","shapes","selectShape","hasSameColor","s","getShape","color","isValid","index","indexOf","splice","existsAt","push","find","giveFocus","removeFocus","update","inputManager","delta","left","right","up","down","max","min","rotateLeft","rotate","filter","render","ctx","fillStyle","fillRect","$00387b554b88a86f$export$14a5666d9e2a0a92","globalAlpha","beginPath","moveTo","lineTo","fill","strokeStyle","strokeRect","font","textBaseline","fillText","letter","$2ce087bca3075e18$export$3c5f89dae98e900b","n","random","$2ce087bca3075e18$export$114aa43ee4755930","array","length","$376aef2b802d0445$export$2e2bcd8739ae039","cursorIndex","onRun","gridPos","onSelection","forEach","rotation","addShape","pressedUp","pressedDown","removedShape","i","startY","startX","width","height","$00387b554b88a86f$export$1ac198198c587660","sin","closePath","stroke","$47117747e6c50692$export$2e2bcd8739ae039","grid","word","onSuccess","setWord","accept","cancel","progressWidth","offsetX","offsetY","text_color","$35d204e98b857052$export$2e2bcd8739ae039","binding","w","h","canvas","event","canvasRect","getBoundingClientRect","newState","touch","targetTouches","clientX","clientY","button","$d12e779adf4758b5$var$CENTER_LEN","$d12e779adf4758b5$var$MAX_SHAPE_SIDE_LEN","$d12e779adf4758b5$export$2e2bcd8739ae039","isColumn","count","j","canSet","getIndex","set","value","countBlocks","recalculateCenter","bounds","top","bottom","validPositions","trueCenter","sort","posA","posB","manhattanDistA","abs","newCenter","updatedBlocks","oldX","oldY","transformedX","transformedY","$2a59e984b87de363$var$COLORS","$09b17a1eda282565$export$2e2bcd8739ae039","$2fdd4cd8dcfa2293$export$2e2bcd8739ae039","Array","isArray","TypeError","newIndex","$2a59e984b87de363$var$internalGenerateWordShapes","nextRun","colors","$2a59e984b87de363$var$generateColors","includes","colorOffset","spread","run","hasSameColorNeighbor","focusOn","ui","window","innerHeight","innerWidth","$35da740d59af89ba$var$canvas","querySelector","$35da740d59af89ba$var$ctx","getContext","$35da740d59af89ba$var$game","$35da740d59af89ba$var$gameLoop","time","requestAnimationFrame"],"version":3,"file":"index.a8ac4073.js.map"}