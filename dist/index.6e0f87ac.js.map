{"mappings":"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","sources":["src/input_manager.js","src/ui/shared_constants.js","src/ui/grid.js","src/random.js","src/ui/inventory.js","src/ui/run_line.js","src/ui/buttons.js","src/shape.js","src/generation.js","src/words.js","src/index.js","src/ui/game.js","node_modules/array-shuffle/index.js"],"sourcesContent":["export const InputEnum = {\n  UP: 0,\n  DOWN: 1,\n  LEFT: 2,\n  RIGHT: 3,\n  A: 4,\n  B: 5,\n  START: 6,\n  L: 7,\n  R: 8,\n  SIZE: 9,\n};\n\nconst KeyboardBinding = {\n  ArrowUp: InputEnum.UP,\n  ArrowDown: InputEnum.DOWN,\n  ArrowLeft: InputEnum.LEFT,\n  ArrowRight: InputEnum.RIGHT,\n  KeyZ: InputEnum.A,\n  KeyX: InputEnum.B,\n  Enter: InputEnum.START,\n  KeyA: InputEnum.L,\n  KeyS: InputEnum.R,\n};\n\nexport class InputManager {\n  #pressed = [];\n  #repeated = [];\n  #held = [];\n  #released = [];\n\n  constructor() {\n    document.addEventListener(\"keydown\", (e) => {\n      const input = KeyboardBinding[e.code];\n\n      if (input != undefined) {\n        this.simulateRepeat(input);\n        this.simulatePress(input);\n      }\n    });\n\n    document.addEventListener(\"keyup\", (e) => {\n      const input = KeyboardBinding[e.code];\n\n      if (input != undefined) {\n        this.simulateRelease(input);\n      }\n    });\n  }\n\n  simulatePress(input) {\n    if (!this.#held[input]) {\n      this.#pressed[input] = true;\n      this.#held[input] = true;\n    }\n  }\n\n  simulateRepeat(input) {\n    // todo, handle using counters\n    if (this.#held[input]) {\n      this.#repeated[input] = true;\n    }\n  }\n\n  simulateRelease(input) {\n    if (input != undefined && this.#held[input]) {\n      this.#released[input] = true;\n      this.#held[input] = false;\n    }\n  }\n\n  justPressed(input) {\n    return this.#pressed[input] == true;\n  }\n\n  justRepeated(input) {\n    return this.#repeated[input] == true;\n  }\n\n  justReleased(input) {\n    return this.#released[input] == true;\n  }\n\n  isDown(input) {\n    return this.#held[input] == true;\n  }\n\n  flush() {\n    this.#pressed = [];\n    this.#released = [];\n    this.#repeated = [];\n  }\n}\n","export const GAME_WIDTH = 240;\nexport const GAME_HEIGHT = 160;\n\nexport const BLOCK_RENDER_SIDE_LEN = 20;\n\nexport const GRID_BLOCK_SIDE_LEN = 5;\nexport const GRID_BLOCK_CENTER = Math.floor(GRID_BLOCK_SIDE_LEN / 2);\nexport const GRID_RENDER_SIDE_LEN = GRID_BLOCK_SIDE_LEN * BLOCK_RENDER_SIDE_LEN;\nexport const GRID_RENDER_OFFSET_X = BLOCK_RENDER_SIDE_LEN;\nexport const GRID_RENDER_OFFSET_Y = BLOCK_RENDER_SIDE_LEN * 1.5;\n\nexport const INVENTORY_OFFSET_X =\n  GRID_RENDER_OFFSET_X + GRID_RENDER_SIDE_LEN + BLOCK_RENDER_SIDE_LEN;\nexport const INVENTORY_OFFSET_Y = GRID_RENDER_OFFSET_Y;\n\nexport const BORDER_COLOR = \"#889EB3\";\nexport const GRID_BACKGROUND_COLOR = \"#124D7F\";\n","import { InputEnum } from \"../input_manager\";\nimport {\n  BLOCK_RENDER_SIDE_LEN,\n  GRID_BLOCK_SIDE_LEN,\n  GRID_RENDER_SIDE_LEN,\n  GRID_RENDER_OFFSET_X,\n  GRID_RENDER_OFFSET_Y,\n  BORDER_COLOR,\n} from \"./shared_constants\";\n\nconst GRID_BORDER_SIZE = 6;\n\nexport default class Grid {\n  #hasFocus = false;\n  #focusedTime = 0;\n  #selectedShape = null;\n  #shapes = [];\n\n  cursorPos = {\n    x: 2,\n    y: 2,\n  };\n\n  onExit = () => {};\n  onReturnShape = (shape) => {};\n\n  setShapes(shapes) {\n    this.#shapes = shapes;\n  }\n\n  selectShape(shape) {\n    this.#selectedShape = shape;\n  }\n\n  #hasSameColorNeighbor(shape, x, y) {\n    const hasSameColor = (x, y) => {\n      const s = this.getShape(x, y);\n      return s && s != shape && s.color == shape.color;\n    };\n\n    return (\n      hasSameColor(x - 1, y) ||\n      hasSameColor(x + 1, y) ||\n      hasSameColor(x, y - 1) ||\n      hasSameColor(x, y + 1)\n    );\n  }\n\n  isValid() {\n    for (let y = 0; y < GRID_BLOCK_SIDE_LEN; y++) {\n      for (let x = 0; x < GRID_BLOCK_SIDE_LEN; x++) {\n        const shape = this.getShape(x, y);\n\n        if (!shape) continue;\n\n        if (this.#hasSameColorNeighbor(shape, x, y)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  #grabShape() {\n    const shape = this.getShape(this.cursorPos.x, this.cursorPos.y);\n\n    if (!shape) {\n      return null;\n    }\n\n    const index = this.#shapes.indexOf(shape);\n    this.#shapes.splice(index, 1);\n\n    this.#selectedShape = shape;\n    this.cursorPos.x = shape.x;\n    this.cursorPos.y = shape.y;\n\n    return shape;\n  }\n\n  #keepSelectedShapeInBounds() {\n    if (!this.#selectedShape) {\n      return;\n    }\n\n    let moved = false;\n\n    do {\n      for (let x = 0; x < GRID_BLOCK_SIDE_LEN; x++) {\n        if (this.#selectedShape.existsAt(x, -1)) {\n          this.#selectedShape.y += 1;\n        }\n\n        if (this.#selectedShape.existsAt(x, GRID_BLOCK_SIDE_LEN)) {\n          this.#selectedShape.y -= 1;\n        }\n      }\n\n      for (let y = 0; y < GRID_BLOCK_SIDE_LEN; y++) {\n        if (this.#selectedShape.existsAt(-1, y)) {\n          this.#selectedShape.x += 1;\n        }\n\n        if (this.#selectedShape.existsAt(GRID_BLOCK_SIDE_LEN, y)) {\n          this.#selectedShape.x -= 1;\n        }\n      }\n    } while (moved);\n\n    this.cursorPos.x = this.#selectedShape.x;\n    this.cursorPos.y = this.#selectedShape.y;\n  }\n\n  #placeSelectedShape() {\n    if (!this.#selectedShape) return false;\n\n    for (let x = 0; x < GRID_BLOCK_SIDE_LEN; x++) {\n      for (let y = 0; y < GRID_BLOCK_SIDE_LEN; y++) {\n        if (!this.#selectedShape.existsAt(x, y)) continue;\n\n        const shape = this.getShape(x, y);\n\n        if (shape) {\n          // todo: play sfx on fail?\n          return false;\n        }\n      }\n    }\n\n    this.#shapes.push(this.#selectedShape);\n    this.#selectedShape = null;\n    return true;\n  }\n\n  getShape(x, y) {\n    return this.#shapes.find((shape) => shape.existsAt(x, y));\n  }\n\n  giveFocus() {\n    this.#hasFocus = true;\n    this.#focusedTime = 0;\n  }\n\n  removeFocus() {\n    this.#hasFocus = false;\n  }\n\n  update(inputManager, delta) {\n    this.#focusedTime += delta;\n\n    const left =\n      inputManager.justPressed(InputEnum.LEFT) ||\n      inputManager.justRepeated(InputEnum.LEFT);\n    const right =\n      inputManager.justPressed(InputEnum.RIGHT) ||\n      inputManager.justRepeated(InputEnum.RIGHT);\n    const up =\n      inputManager.justPressed(InputEnum.UP) ||\n      inputManager.justRepeated(InputEnum.UP);\n    const down =\n      inputManager.justPressed(InputEnum.DOWN) ||\n      inputManager.justRepeated(InputEnum.DOWN);\n\n    if (left) {\n      this.cursorPos.x -= 1;\n    }\n    if (right) {\n      this.cursorPos.x += 1;\n    }\n    if (up) {\n      this.cursorPos.y -= 1;\n    }\n    if (down) {\n      this.cursorPos.y += 1;\n    }\n\n    if (!this.#selectedShape && this.cursorPos.x >= GRID_BLOCK_SIDE_LEN) {\n      this.onExit(this.cursorPos);\n    }\n\n    this.cursorPos.x = Math.max(0, this.cursorPos.x);\n    this.cursorPos.x = Math.min(GRID_BLOCK_SIDE_LEN - 1, this.cursorPos.x);\n    this.cursorPos.y = Math.max(0, this.cursorPos.y);\n    this.cursorPos.y = Math.min(GRID_BLOCK_SIDE_LEN - 1, this.cursorPos.y);\n\n    if (this.#selectedShape) {\n      this.#selectedShape.x = this.cursorPos.x;\n      this.#selectedShape.y = this.cursorPos.y;\n\n      if (inputManager.justPressed(InputEnum.L)) {\n        this.#selectedShape.rotateLeft();\n      }\n      if (inputManager.justPressed(InputEnum.R)) {\n        this.#selectedShape.rotate();\n      }\n\n      this.#keepSelectedShapeInBounds();\n\n      if (inputManager.justPressed(InputEnum.A)) {\n        this.#placeSelectedShape();\n      } else if (inputManager.justPressed(InputEnum.B)) {\n        const shape = this.#selectedShape;\n        this.#selectedShape = null;\n\n        this.#shapes = this.#shapes.filter((s) => s != shape);\n        this.onReturnShape(shape);\n      }\n    } else {\n      if (inputManager.justPressed(InputEnum.A)) {\n        this.#grabShape();\n      } else if (inputManager.justPressed(InputEnum.B)) {\n        this.onExit(this.cursorPos);\n      }\n    }\n  }\n\n  render(ctx) {\n    // border\n    ctx.fillStyle = BORDER_COLOR;\n    ctx.fillRect(\n      GRID_RENDER_OFFSET_X - GRID_BORDER_SIZE,\n      GRID_RENDER_OFFSET_Y - GRID_BORDER_SIZE,\n      GRID_RENDER_SIDE_LEN + GRID_BORDER_SIZE * 2,\n      GRID_RENDER_SIDE_LEN + GRID_BORDER_SIZE * 2\n    );\n\n    // background\n    ctx.fillStyle = \"#124D7F\";\n    ctx.fillRect(\n      GRID_RENDER_OFFSET_X,\n      GRID_RENDER_OFFSET_Y,\n      GRID_RENDER_SIDE_LEN,\n      GRID_RENDER_SIDE_LEN\n    );\n\n    // blocks\n    for (let x = 0; x < GRID_BLOCK_SIDE_LEN; x++) {\n      for (let y = 0; y < GRID_BLOCK_SIDE_LEN; y++) {\n        const shape = this.getShape(x, y);\n\n        if (shape) {\n          ctx.fillStyle = shape.color;\n          ctx.fillRect(\n            GRID_RENDER_OFFSET_X + BLOCK_RENDER_SIDE_LEN * x,\n            GRID_RENDER_OFFSET_Y + BLOCK_RENDER_SIDE_LEN * y,\n            BLOCK_RENDER_SIDE_LEN,\n            BLOCK_RENDER_SIDE_LEN\n          );\n        }\n\n        if (this.#selectedShape && this.#selectedShape.existsAt(x, y)) {\n          ctx.globalAlpha = 0.75;\n          ctx.fillStyle = this.#selectedShape.color;\n          ctx.fillRect(\n            GRID_RENDER_OFFSET_X + BLOCK_RENDER_SIDE_LEN * x,\n            GRID_RENDER_OFFSET_Y + BLOCK_RENDER_SIDE_LEN * y,\n            BLOCK_RENDER_SIDE_LEN,\n            BLOCK_RENDER_SIDE_LEN\n          );\n\n          ctx.globalAlpha = 1;\n        }\n      }\n    }\n\n    ctx.fillStyle = \"#00000033\";\n    ctx.beginPath();\n    // to the right\n    ctx.moveTo(\n      GRID_RENDER_OFFSET_X,\n      GRID_RENDER_OFFSET_Y + BLOCK_RENDER_SIDE_LEN * 2\n    );\n    ctx.lineTo(\n      GRID_RENDER_OFFSET_X + GRID_RENDER_SIDE_LEN,\n      GRID_RENDER_OFFSET_Y + BLOCK_RENDER_SIDE_LEN * 2\n    );\n\n    // center\n    ctx.lineTo(\n      GRID_RENDER_OFFSET_X + GRID_RENDER_SIDE_LEN,\n      GRID_RENDER_OFFSET_Y + BLOCK_RENDER_SIDE_LEN * 2.5\n    );\n\n    // back to the left\n    ctx.lineTo(\n      GRID_RENDER_OFFSET_X + GRID_RENDER_SIDE_LEN,\n      GRID_RENDER_OFFSET_Y + BLOCK_RENDER_SIDE_LEN * 3\n    );\n    ctx.lineTo(\n      GRID_RENDER_OFFSET_X,\n      GRID_RENDER_OFFSET_Y + BLOCK_RENDER_SIDE_LEN * 3\n    );\n\n    // auto closes\n    ctx.fill();\n\n    // draw cursor\n    if (this.#hasFocus) {\n      const { x, y } = this.cursorPos;\n      ctx.strokeStyle = \"#E02828\";\n\n      ctx.strokeRect(\n        GRID_RENDER_OFFSET_X + BLOCK_RENDER_SIDE_LEN * x + 0.5,\n        GRID_RENDER_OFFSET_Y + BLOCK_RENDER_SIDE_LEN * y + 0.5,\n        BLOCK_RENDER_SIDE_LEN - 1,\n        BLOCK_RENDER_SIDE_LEN - 1\n      );\n\n      const shape = this.getShape(x, y);\n\n      if (!this.#selectedShape && shape) {\n        ctx.font = \"16px bn6-bold\";\n        ctx.textBaseline = \"top\";\n        ctx.fillText(\n          shape.letter,\n          GRID_RENDER_OFFSET_X + BLOCK_RENDER_SIDE_LEN * x + 6,\n          GRID_RENDER_OFFSET_Y + BLOCK_RENDER_SIDE_LEN * y + 3\n        );\n      }\n    }\n  }\n}\n","// [0, n)\nexport function randomInt(n) {\n  return Math.floor(Math.random() * n);\n}\n\nexport function randomItem(array) {\n  return array[randomInt(array.length)];\n}\n","import {\n  INVENTORY_OFFSET_X,\n  INVENTORY_OFFSET_Y,\n  BLOCK_RENDER_SIDE_LEN,\n  GRID_BLOCK_SIDE_LEN,\n  BORDER_COLOR,\n  GRID_BACKGROUND_COLOR,\n} from \"./shared_constants\";\nimport { InputEnum } from \"../input_manager\";\nimport { randomInt } from \"../random\";\n\nexport default class Inventory {\n  #hasFocus = false;\n  #focusTime = 0;\n  #shapes = [];\n\n  cursorIndex = 0;\n  onRun = () => {};\n  onExit = (gridPos) => {};\n  onSelection = (shape) => {};\n\n  giveFocus() {\n    this.#hasFocus = true;\n    this.#focusTime = 0;\n  }\n\n  removeFocus() {\n    this.#hasFocus = false;\n    this.#focusTime = 0;\n  }\n\n  setShapes(shapes) {\n    shapes.forEach((shape) => {\n      shape.x = Math.floor(GRID_BLOCK_SIDE_LEN / 2);\n      shape.y = Math.floor(GRID_BLOCK_SIDE_LEN / 2);\n      shape.rotation = randomInt(4);\n    });\n\n    this.#shapes = shapes;\n  }\n\n  addShape(shape) {\n    shape.x = Math.floor(GRID_BLOCK_SIDE_LEN / 2);\n    shape.y = Math.floor(GRID_BLOCK_SIDE_LEN / 2);\n    this.#shapes.push(shape);\n  }\n\n  update(inputManager, delta) {\n    this.#focusTime += delta;\n\n    if (inputManager.justPressed(InputEnum.LEFT)) {\n      this.onExit(this.cursorIndex);\n      return;\n    }\n\n    const pressedUp =\n      inputManager.justPressed(InputEnum.UP) ||\n      inputManager.justRepeated(InputEnum.UP);\n\n    const pressedDown =\n      inputManager.justPressed(InputEnum.DOWN) ||\n      inputManager.justRepeated(InputEnum.DOWN);\n\n    if (pressedUp) {\n      this.cursorIndex -= 1;\n    }\n    if (pressedDown) {\n      this.cursorIndex += 1;\n    }\n\n    this.cursorIndex = Math.max(0, this.cursorIndex);\n    this.cursorIndex = Math.min(this.#shapes.length, this.cursorIndex);\n\n    if (inputManager.justPressed(InputEnum.A)) {\n      if (this.cursorIndex < this.#shapes.length) {\n        const [removedShape] = this.#shapes.splice(this.cursorIndex, 1);\n        this.onSelection(removedShape);\n      } else {\n        this.onRun();\n      }\n    }\n  }\n\n  render(ctx) {\n    ctx.font = \"16px bn6-bold\";\n    ctx.textBaseline = \"top\";\n    const width = 26;\n    const height = 15;\n\n    for (let i = 0; i < this.#shapes.length; i++) {\n      const shape = this.#shapes[i];\n\n      const startX = INVENTORY_OFFSET_X;\n      const startY = INVENTORY_OFFSET_Y + BLOCK_RENDER_SIDE_LEN * i;\n\n      // render border\n      ctx.fillStyle = BORDER_COLOR;\n      ctx.fillRect(startX - 2, startY - 2, width + 4, height + 4);\n\n      // render bg\n      ctx.fillStyle = GRID_BACKGROUND_COLOR;\n      ctx.fillRect(startX, startY, width, height);\n\n      // render mini shape\n      ctx.fillStyle = shape.color;\n      for (let x = 0; x < 5; x++) {\n        for (let y = 0; y < 5; y++) {\n          if (!shape.existsAt(x, y)) continue;\n\n          ctx.fillRect(startX + x * 3 + 11, startY + y * 3, 3, 3);\n        }\n      }\n\n      ctx.fillStyle = \"white\";\n      ctx.fillText(shape.letter, startX + 1, startY + 1);\n    }\n\n    // render run button\n    {\n      const startX = INVENTORY_OFFSET_X;\n      const startY =\n        INVENTORY_OFFSET_Y + BLOCK_RENDER_SIDE_LEN * this.#shapes.length;\n\n      // render border\n      ctx.fillStyle = BORDER_COLOR;\n      ctx.fillRect(startX - 2, startY - 2, width + 4, height + 4);\n\n      // render bg\n      ctx.fillStyle = \"lime\";\n      ctx.fillRect(startX, startY, width, height);\n\n      ctx.fillStyle = \"white\";\n      ctx.fillText(\"RUN\", startX + 1, startY + 1);\n    }\n\n    if (this.#hasFocus) {\n      const startX = INVENTORY_OFFSET_X - 9 + Math.sin(this.#focusTime * 16);\n      const startY =\n        INVENTORY_OFFSET_Y + BLOCK_RENDER_SIDE_LEN * this.cursorIndex;\n\n      ctx.strokeStyle = \"green\";\n      ctx.fillStyle = \"lime\";\n      ctx.beginPath();\n      ctx.moveTo(startX, startY);\n      ctx.lineTo(startX + 8, startY + height / 2);\n      ctx.lineTo(startX, startY + height);\n      ctx.closePath();\n      ctx.fill();\n      ctx.stroke();\n    }\n  }\n}\n","import { InputEnum } from \"../input_manager\";\nimport {\n  BLOCK_RENDER_SIDE_LEN,\n  GRID_RENDER_SIDE_LEN,\n  GRID_RENDER_OFFSET_X,\n  GRID_RENDER_OFFSET_Y,\n  GRID_BLOCK_SIDE_LEN,\n  GRID_BLOCK_CENTER,\n} from \"./shared_constants\";\n\nexport default class RunLine {\n  #progress = 0;\n  #grid;\n  #word;\n  #builtWord;\n  #validGrid;\n\n  constructor(grid, word) {\n    this.#grid = grid;\n  }\n\n  onSuccess = () => {};\n  onExit = () => {};\n\n  setWord(word) {\n    this.#word = word;\n  }\n\n  giveFocus() {\n    this.#progress = 0;\n    this.#builtWord = null;\n  }\n\n  removeFocus() {\n    this.#progress = 0;\n  }\n\n  #reviewGrid() {\n    this.#builtWord = \"\";\n\n    for (let i = 0; i < GRID_BLOCK_SIDE_LEN; i++) {\n      const shape = this.#grid.getShape(i, GRID_BLOCK_CENTER);\n\n      this.#builtWord += shape ? shape.letter : \"?\";\n    }\n\n    this.#validGrid = this.#grid.isValid();\n  }\n\n  update(inputManager, delta) {\n    this.#progress = Math.min(1, this.#progress + delta / 2);\n\n    const accept = inputManager.justPressed(InputEnum.A);\n    const cancel = inputManager.justPressed(InputEnum.B);\n\n    if ((accept || cancel) && this.#progress == 1) {\n      this.onExit();\n    }\n\n    if (!this.#builtWord && this.#progress == 1) {\n      this.#reviewGrid();\n    }\n  }\n\n  #renderLine(ctx) {\n    ctx.beginPath();\n\n    const progressWidth = GRID_RENDER_SIDE_LEN * this.#progress;\n\n    // to the right\n    ctx.moveTo(\n      GRID_RENDER_OFFSET_X,\n      GRID_RENDER_OFFSET_Y + BLOCK_RENDER_SIDE_LEN * 2\n    );\n    ctx.lineTo(\n      GRID_RENDER_OFFSET_X + progressWidth,\n      GRID_RENDER_OFFSET_Y + BLOCK_RENDER_SIDE_LEN * 2\n    );\n\n    // center\n    ctx.lineTo(\n      GRID_RENDER_OFFSET_X + progressWidth,\n      GRID_RENDER_OFFSET_Y + BLOCK_RENDER_SIDE_LEN * 2.5\n    );\n\n    // back to the left\n    ctx.lineTo(\n      GRID_RENDER_OFFSET_X + progressWidth,\n      GRID_RENDER_OFFSET_Y + BLOCK_RENDER_SIDE_LEN * 3\n    );\n    ctx.lineTo(\n      GRID_RENDER_OFFSET_X,\n      GRID_RENDER_OFFSET_Y + BLOCK_RENDER_SIDE_LEN * 3\n    );\n\n    ctx.fill();\n  }\n\n  #renderText(ctx, offsetX, offsetY) {\n    for (let i = 0; i < GRID_BLOCK_SIDE_LEN * this.#progress - 0.5; i++) {\n      const shape = this.#grid.getShape(i, GRID_BLOCK_CENTER);\n\n      ctx.font = \"16px bn6-bold\";\n      ctx.fillText(\n        shape ? shape.letter : \"?\",\n        GRID_RENDER_OFFSET_X + BLOCK_RENDER_SIDE_LEN * i + 6 + offsetX,\n        GRID_RENDER_OFFSET_Y +\n          BLOCK_RENDER_SIDE_LEN * GRID_BLOCK_CENTER +\n          3 +\n          offsetY\n      );\n    }\n  }\n\n  render(ctx) {\n    ctx.fillStyle = \"#ffff0066\";\n\n    this.#renderLine(ctx);\n\n    // text shadow\n    this.#renderText(ctx, 1, 1);\n\n    if (this.#progress < 1) {\n      ctx.fillStyle = \"black\";\n    } else if (this.#builtWord == this.#word) {\n      ctx.fillStyle = this.#validGrid ? \"lime\" : \"orange\";\n    } else {\n      ctx.fillStyle = \"red\";\n    }\n\n    this.#renderText(ctx, 0, 0);\n  }\n}\n","import { GAME_WIDTH, GAME_HEIGHT } from \"./shared_constants\";\nimport { InputEnum } from \"../input_manager\";\n\nconst BUTTON_SIZE = 24;\n\nexport default class Buttons {\n  #buttons = [\n    {\n      binding: InputEnum.L,\n      x: 0,\n      y: 1,\n      w: 2,\n      h: 1,\n    },\n    {\n      binding: InputEnum.R,\n      x: GAME_WIDTH / BUTTON_SIZE - 2,\n      y: 1,\n      w: 2,\n      h: 1,\n    },\n    {\n      binding: InputEnum.LEFT,\n      x: 1,\n      y: 4,\n      w: 1,\n      h: 1,\n    },\n    {\n      binding: InputEnum.RIGHT,\n      x: 3,\n      y: 4,\n      w: 1,\n      h: 1,\n    },\n    {\n      binding: InputEnum.UP,\n      x: 2,\n      y: 3,\n      w: 1,\n      h: 1,\n    },\n    {\n      binding: InputEnum.DOWN,\n      x: 2,\n      y: 5,\n      w: 1,\n      h: 1,\n    },\n    {\n      binding: InputEnum.A,\n      x: GAME_WIDTH / BUTTON_SIZE - 3,\n      y: 3,\n      w: 1,\n      h: 1,\n    },\n    {\n      binding: InputEnum.B,\n      x: GAME_WIDTH / BUTTON_SIZE - 4,\n      y: 4,\n      w: 1,\n      h: 1,\n    },\n  ];\n  #canvas;\n  #state = [];\n  #inputManager;\n\n  constructor(canvas, inputManager) {\n    this.#canvas = canvas;\n    this.#inputManager = inputManager;\n\n    canvas.addEventListener(\"touchstart\", (e) => {\n      this.#updateFromTouchEvent(e);\n    });\n\n    canvas.addEventListener(\"touchmove\", (e) => {\n      this.#updateFromTouchEvent(e);\n    });\n\n    canvas.addEventListener(\"touchend\", (e) => {\n      this.#updateFromTouchEvent(e);\n    });\n  }\n\n  #updateFromTouchEvent(event) {\n    const canvas = this.#canvas;\n    const canvasRect = canvas.getBoundingClientRect();\n\n    const newState = [];\n\n    for (const touch of event.targetTouches) {\n      // get corrected canvas position\n      let x =\n        ((touch.clientX - canvasRect.x) / canvasRect.width) * canvas.width;\n      let y =\n        ((touch.clientY - canvasRect.y) / canvasRect.height) * canvas.height;\n\n      // transform position to button space\n      x = x / BUTTON_SIZE;\n      y = (y - GAME_HEIGHT) / BUTTON_SIZE;\n\n      for (const button of this.#buttons) {\n        if (\n          x > button.x &&\n          y > button.y &&\n          x < button.x + button.w &&\n          y < button.y + button.h\n        ) {\n          newState[button.binding] = true;\n        }\n      }\n    }\n\n    for (let i = 0; i < InputEnum.SIZE; i++) {\n      if (this.#state[i] && !newState[i]) {\n        this.#inputManager.simulateRelease(i);\n      } else if (!this.#state[i] && newState[i]) {\n        this.#inputManager.simulatePress(i);\n      }\n    }\n\n    this.#state = newState;\n  }\n\n  update() {\n    for (let i = 0; i < InputEnum.SIZE; i++) {\n      if (this.#state[i]) {\n        this.#inputManager.simulatePress(i);\n      }\n    }\n  }\n\n  render(ctx) {\n    ctx.fillStyle = \"white\";\n\n    for (const button of this.#buttons) {\n      ctx.fillRect(\n        button.x * BUTTON_SIZE,\n        GAME_HEIGHT + button.y * BUTTON_SIZE,\n        button.w * BUTTON_SIZE,\n        button.h * BUTTON_SIZE\n      );\n    }\n  }\n}\n","const MAX_SHAPE_SIDE_LEN = 5;\nconst CENTER_LEN = Math.floor(MAX_SHAPE_SIDE_LEN / 2);\n\nexport default class Shape {\n  #blocks = [];\n\n  constructor() {\n    this.color = \"\";\n    this.letter = \"\";\n    this.x = 0;\n    this.y = 0;\n    this.rotation = 0;\n\n    for (let i = 0; i < MAX_SHAPE_SIDE_LEN * MAX_SHAPE_SIDE_LEN; i++) {\n      this.#blocks[i] = false;\n    }\n  }\n\n  isColumn() {\n    let count = 0;\n\n    for (let i = 0; i < MAX_SHAPE_SIDE_LEN; i++) {\n      for (let j = 0; j < MAX_SHAPE_SIDE_LEN; j++) {\n        const index = i * MAX_SHAPE_SIDE_LEN + j;\n\n        if (!this.#blocks[index]) continue;\n\n        if (j != CENTER_LEN) {\n          // found a block outside of a column\n          return false;\n        }\n\n        count++;\n      }\n    }\n\n    // 1x1 is not a column\n    return count > 1;\n  }\n\n  rotate() {\n    this.rotation += 1;\n    this.rotation %= 4;\n  }\n\n  rotateLeft() {\n    this.rotation -= 1;\n\n    if (this.rotation < 0) {\n      this.rotation = 3;\n    }\n  }\n\n  canSet(x, y) {\n    const index = this.getIndex(x, y);\n    return index >= 0 && index < MAX_SHAPE_SIDE_LEN * MAX_SHAPE_SIDE_LEN;\n  }\n\n  set(x, y, value) {\n    const index = this.getIndex(x, y);\n    this.#blocks[index] = value;\n  }\n\n  existsAt(x, y) {\n    const index = this.getIndex(x, y);\n    return this.#blocks[index] == true;\n  }\n\n  countBlocks() {\n    let count = 0;\n\n    for (let i = 0; i < this.#blocks.length; i++) {\n      if (this.#blocks[i]) {\n        count++;\n      }\n    }\n\n    return count;\n  }\n\n  recalculateCenter() {\n    const bounds = {\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n    };\n\n    const validPositions = [];\n\n    for (let i = 0; i < MAX_SHAPE_SIDE_LEN; i++) {\n      for (let j = 0; j < MAX_SHAPE_SIDE_LEN; j++) {\n        const index = i * MAX_SHAPE_SIDE_LEN + j;\n\n        if (!this.#blocks[index]) continue;\n\n        const x = j - CENTER_LEN;\n        const y = i - CENTER_LEN;\n\n        if (x < bounds.left) {\n          bounds.left = x;\n        }\n        if (y < bounds.top) {\n          bounds.top = y;\n        }\n        if (x > bounds.right) {\n          bounds.right = x;\n        }\n        if (y > bounds.bottom) {\n          bounds.bottom = y;\n        }\n\n        validPositions.push({ x, y });\n      }\n    }\n\n    const trueCenter = {\n      x: (bounds.left + bounds.right) / 2,\n      y: (bounds.bottom + bounds.top) / 2,\n    };\n\n    validPositions.sort((posA, posB) => {\n      const manhattanDistA =\n        Math.abs(trueCenter.x - posA.x) + Math.abs(trueCenter.y - posA.y);\n      const manhattanDistB =\n        Math.abs(trueCenter.x - posB.x) + Math.abs(trueCenter.y - posB.y);\n\n      return manhattanDistA < manhattanDistB ? -1 : 1;\n    });\n\n    const newCenter = validPositions[0];\n    this.x -= newCenter.x;\n    this.y -= newCenter.y;\n\n    const updatedBlocks = [...this.#blocks];\n\n    for (let i = 0; i < MAX_SHAPE_SIDE_LEN; i++) {\n      for (let j = 0; j < MAX_SHAPE_SIDE_LEN; j++) {\n        let value = false;\n\n        const oldX = j + newCenter.x;\n        const oldY = i + newCenter.y;\n\n        if (\n          oldX >= 0 &&\n          oldY >= 0 &&\n          oldX < MAX_SHAPE_SIDE_LEN &&\n          oldY < MAX_SHAPE_SIDE_LEN\n        ) {\n          const index = oldY * MAX_SHAPE_SIDE_LEN + oldX;\n          value = this.#blocks[index];\n        }\n\n        const index = i * MAX_SHAPE_SIDE_LEN + j;\n        updatedBlocks[index] = value;\n      }\n    }\n\n    this.#blocks = updatedBlocks;\n  }\n\n  getIndex(x, y) {\n    x = x - this.x;\n    y = y - this.y;\n    let transformedX, transformedY;\n\n    switch (this.rotation) {\n      case 0:\n        // [x-y-, x+y-]\n        // [x-y+, x+y+]\n        transformedX = x;\n        transformedY = y;\n        break;\n      case 1:\n        // 90 clockwise\n        // [x-y+, x-y-]\n        // [x+y+, x+y-]\n        transformedX = y;\n        transformedY = CENTER_LEN - x - 2;\n        break;\n      case 2:\n        // 180\n        // [x+y+, x-y+]\n        // [x+y-, x-y-]\n        transformedX = CENTER_LEN - x - 2;\n        transformedY = CENTER_LEN - y - 2;\n        break;\n      case 3:\n        // 270\n        // [x+y-, x+y+]\n        // [x-y-, x-y+]\n        transformedX = CENTER_LEN - y - 2;\n        transformedY = x;\n        break;\n    }\n\n    transformedX += CENTER_LEN;\n    transformedY += CENTER_LEN;\n\n    if (\n      transformedX < 0 ||\n      transformedY < 0 ||\n      transformedX >= MAX_SHAPE_SIDE_LEN ||\n      transformedY >= MAX_SHAPE_SIDE_LEN\n    ) {\n      return -1;\n    }\n\n    return transformedY * MAX_SHAPE_SIDE_LEN + transformedX;\n  }\n}\n","import Shape from \"./shape\";\nimport { randomInt, randomItem } from \"./random\";\n\nconst GRID_SIDE_LEN = 5;\nlet COLORS = [\"#DE1100\", \"#D688C0\", \"#2880D9\", \"#19C000\", \"#D8DA00\", \"#D8D8D8\"];\nconst MAX_SHAPE_SIZE = 4;\nconst MAX_COLORS = 4;\n\nfunction generateColors() {\n  const colors = [];\n\n  while (colors.length < MAX_COLORS) {\n    const color = randomItem(COLORS);\n\n    if (!colors.includes(color)) {\n      colors.push(color);\n    }\n  }\n\n  return colors;\n}\n\nfunction internalGenerateWordShapes(word) {\n  let shapes = [];\n  let nextRun = [];\n  let colors = generateColors();\n  let colorOffset = randomInt(colors.length);\n\n  for (let i = 0; i < GRID_SIDE_LEN; i++) {\n    const shape = new Shape();\n    shape.color = colors[(i + colorOffset) % colors.length];\n    shape.x = i;\n    shape.y = 2;\n    shape.letter = word[i];\n\n    shape.set(shape.x, shape.y, true);\n    shapes.push(shape);\n\n    nextRun.push({\n      shape,\n      x: shape.x,\n      y: shape.y - 1,\n    });\n\n    nextRun.push({\n      shape,\n      x: shape.x,\n      y: shape.y + 1,\n    });\n\n    if (word[i] == word[i + 1]) {\n      // merge repeated letter\n      shape.set(shape.x + 1, shape.y, true);\n      i++;\n\n      nextRun.push({\n        shape,\n        x: shape.x + 1,\n        y: shape.y - 1,\n      });\n\n      nextRun.push({\n        shape,\n        x: shape.x + 1,\n        y: shape.y + 1,\n      });\n    }\n  }\n\n  const spread = ({ shape, x, y }) => {\n    nextRun.push({\n      shape: shape,\n      x: x - 1,\n      y: y,\n    });\n\n    nextRun.push({\n      shape: shape,\n      x: x + 1,\n      y: y,\n    });\n\n    nextRun.push({\n      shape: shape,\n      x: x,\n      y: y - 1,\n    });\n\n    nextRun.push({\n      shape: shape,\n      x: x,\n      y: y + 1,\n    });\n  };\n\n  function hasSameColorNeighbor(shape, x, y) {\n    function hasSameColor(x, y) {\n      const s = shapes.find((shape) => shape.existsAt(x, y));\n      return s && s != shape && s.color == shape.color;\n    }\n\n    return (\n      hasSameColor(x - 1, y) ||\n      hasSameColor(x + 1, y) ||\n      hasSameColor(x, y - 1) ||\n      hasSameColor(x, y + 1)\n    );\n  }\n\n  while (nextRun.length > 0) {\n    const run = nextRun;\n    nextRun = [];\n\n    for (const { shape, x, y } of run) {\n      if (x < 0 || y < 0 || x >= GRID_SIDE_LEN || y >= GRID_SIDE_LEN) {\n        continue;\n      }\n\n      const otherShape = shapes.find((shape) => shape.existsAt(x, y));\n\n      if (otherShape) continue;\n\n      const growShape = () => {\n        // spread if we can, or drop this search\n\n        if (hasSameColorNeighbor(shape, x, y)) {\n          return;\n        }\n\n        if (shape.countBlocks() >= MAX_SHAPE_SIZE || !shape.canSet(x, y)) {\n          return;\n        }\n\n        shape.set(x, y, true);\n        spread({ shape, x, y });\n      };\n\n      const tryLater = () => {\n        // do nothing, but try again next run\n        nextRun.push({ shape, x, y });\n      };\n\n      const options = [growShape, tryLater];\n\n      randomItem(options)();\n    }\n  }\n\n  return shapes;\n}\n\nexport function generateWordShapes(word) {\n  let shapes;\n\n  do {\n    shapes = internalGenerateWordShapes(word);\n  } while (shapes.filter((shape) => shape.isColumn()).length > 1);\n\n  for (const shape of shapes) {\n    shape.recalculateCenter();\n  }\n\n  return shapes;\n}\n\nexport function generateFillerShapes(word) {\n  let shapes;\n\n  do {\n    shapes = internalGenerateWordShapes(word);\n  } while (shapes.filter((shape) => shape.isColumn()).length > 1);\n\n  return shapes;\n}\n","export default [\n  // misc\n  \"ZENNY\",\n  \"CHIPS\",\n  \"CYBER\",\n  \"PANEL\",\n  \"COLOR\",\n  \"POINT\",\n  \"GAUGE\",\n  \"VIRUS\",\n  \"DRILL\",\n  \"SNEAK\",\n  \"HPMEM\",\n  \"BREAK\",\n  // NCP\n  \"SHOES\",\n  \"HUMOR\",\n  \"TANGO\",\n  \"ARMOR\",\n  \"BLOCK\",\n  // humans\n  \"CHAUD\",\n  \"BARYL\",\n  // navis\n  \"GLIDE\",\n  \"PROTO\",\n  // \"NUMBR\", // NumbrMan Chips + NumberMan\n  \"MAGIC\",\n  \"SKULL\",\n  \"SHARK\",\n  \"PHARO\",\n  // \"SHADO\",\n  // \"MAGNT\",\n  // \"NAPLM\",\n  \"METAL\",\n  \"JAPAN\",\n  // \"BUBBL\",\n  \"SPARK\",\n  \"VIDEO\",\n  \"SHADE\",\n  \"COSMO\",\n  \"MEDDY\",\n  \"CHAOS\",\n  \"SPOUT\",\n  \"BLAST\",\n  \"JUDGE\",\n  \"ERASE\",\n  \"TENGU\",\n  \"BEAST\",\n  \"CACHE\",\n  \"KENDO\",\n  \"LASER\",\n  \"QUICK\",\n  \"STONE\",\n  // chips\n  \"STEAL\",\n  \"CLOUD\",\n  \"INVIS\",\n  \"POPUP\",\n  \"SWORD\",\n  \"BLADE\",\n  \"PUNCH\",\n  \"LANCE\",\n  \"GUARD\",\n  \"RECOV\",\n  \"ARROW\",\n  \"SPICE\",\n  \"SHAKE\",\n  \"PANIC\",\n  \"BATCH\",\n  \"SNAKE\",\n  \"QUAKE\",\n  \"DELTA\",\n  \"STAGE\",\n  // viruses\n  \"BILLY\",\n  \"FISHY\",\n  \"RATTY\",\n  \"PUFFY\",\n  \"JELLY\",\n  \"BUNNY\",\n  \"POWIE\",\n  \"PENGI\",\n  \"VINEY\",\n  \"ALPHA\",\n  \"TOTEM\",\n  \"TWINS\",\n  \"KILBY\",\n  \"WALLA\",\n  \"BATTY\",\n  \"HANDI\",\n  \"ZOMON\",\n  \"BRUTE\",\n  \"HEADY\",\n  \"GOLEM\",\n];\n","import Game from \"./ui/game\";\n\nconst canvas = document.querySelector(\"canvas\");\nconst ctx = canvas.getContext(\"2d\");\nconst game = new Game(canvas);\n\nlet previousTime;\n\nfunction gameLoop(time) {\n  if (previousTime == undefined) {\n    previousTime = time;\n    requestAnimationFrame(gameLoop);\n    return;\n  }\n\n  const delta = (time - previousTime) / 1000;\n  previousTime = time;\n\n  game.update(delta);\n  game.render(canvas, ctx);\n\n  requestAnimationFrame(gameLoop);\n}\n\nwindow.addEventListener(\"load\", function () {\n  gameLoop(0);\n});\n","import Grid from \"./grid\";\nimport Inventory from \"./inventory\";\nimport RunLine from \"./run_line\";\nimport Buttons from \"./buttons\";\nimport { GRID_BLOCK_SIDE_LEN, GAME_HEIGHT } from \"./shared_constants\";\nimport { InputManager } from \"../input_manager\";\nimport { randomItem } from \"../random\";\nimport { generateWordShapes } from \"../generation\";\nimport WORDS from \"../words\";\nimport arrayShuffle from \"array-shuffle\";\n\nexport default class Game {\n  #inventory = new Inventory();\n  #grid = new Grid();\n  #runLine = new RunLine(this.#grid);\n  #buttons;\n  #focusedUI = this.#inventory;\n  #inputManager = new InputManager();\n\n  constructor(canvas) {\n    this.#buttons = new Buttons(canvas, this.#inputManager);\n\n    const word = randomItem(WORDS);\n\n    this.#runLine.setWord(word);\n\n    this.#inventory.setShapes(arrayShuffle(generateWordShapes(word)));\n    this.focusOn(this.#inventory);\n\n    this.#inventory.onRun = () => {\n      this.focusOn(this.#runLine);\n    };\n\n    this.#inventory.onSelection = (shape) => {\n      this.#grid.cursorPos = {\n        x: Math.floor(GRID_BLOCK_SIDE_LEN / 2),\n        y: Math.floor(GRID_BLOCK_SIDE_LEN / 2),\n      };\n      this.#grid.selectShape(shape);\n      this.focusOn(this.#grid);\n    };\n\n    this.#inventory.onExit = (index) => {\n      this.#grid.cursorPos = {\n        x: GRID_BLOCK_SIDE_LEN - 1,\n        y: index,\n      };\n      this.focusOn(this.#grid);\n    };\n\n    this.#grid.onReturnShape = (shape) => {\n      this.#inventory.addShape(shape);\n    };\n\n    this.#grid.onExit = (cursorPos) => {\n      this.#inventory.cursorIndex = cursorPos.y;\n      this.focusOn(this.#inventory);\n    };\n\n    this.#runLine.onExit = () => {\n      this.focusOn(this.#inventory);\n    };\n  }\n\n  focusOn(ui) {\n    this.#focusedUI?.removeFocus();\n    this.#focusedUI = ui;\n\n    this.#inputManager.flush();\n    ui.giveFocus();\n    this.update(0);\n  }\n\n  update(delta) {\n    this.#focusedUI.update(this.#inputManager, delta);\n    this.#inputManager.flush();\n    this.#buttons.update();\n  }\n\n  #isLandscape() {\n    if (window.innerHeight < window.innerWidth) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  render(canvas, ctx) {\n    if (this.#isLandscape()) {\n      canvas.height = GAME_HEIGHT;\n    } else {\n      canvas.height = GAME_HEIGHT * 2;\n      this.#buttons.render(ctx);\n    }\n\n    ctx.fillStyle = \"orange\";\n    ctx.fillRect(0, 0, canvas.width, GAME_HEIGHT);\n\n    this.#grid.render(ctx);\n    this.#inventory.render(ctx);\n    this.#runLine.render(ctx);\n  }\n}\n","export default function arrayShuffle(array) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new TypeError(`Expected an array, got ${typeof array}`);\n\t}\n\n\tarray = [...array];\n\n\tfor (let index = array.length - 1; index > 0; index--) {\n\t\tconst newIndex = Math.floor(Math.random() * (index + 1));\n\t\t[array[index], array[newIndex]] = [array[newIndex], array[index]];\n\t}\n\n\treturn array;\n}\n"],"names":["$f8e847403f6cae58$export$17d7fd322af6b968","$f8e847403f6cae58$var$KeyboardBinding","ArrowUp","ArrowDown","ArrowLeft","ArrowRight","KeyZ","KeyX","Enter","KeyA","KeyS","$f8e847403f6cae58$export$2da2653229140a6c","pressed","repeated","held","released","document","addEventListener","e","input","code","undefined","this","simulateRepeat","simulatePress","simulateRelease","justPressed","justRepeated","justReleased","isDown","flush","$00387b554b88a86f$export$d1ce89bfcf9b1ff3","Math","floor","$00387b554b88a86f$export$9188d4e069e95fa0","hasFocus","focusedTime","selectedShape","shapes","cursorPos","x","y","onExit","onReturnShape","shape","setShapes","selectShape","hasSameColorNeighbor","hasSameColor","x1","y1","s","getShape","color","isValid","y2","x2","shape1","grabShape","index","indexOf","splice","keepSelectedShapeInBounds","existsAt","placeSelectedShape","push","x3","y3","find","shape2","giveFocus","removeFocus","update","inputManager","delta","left","right","up","down","max","min","rotateLeft","rotate","shape3","filter","render","ctx","fillStyle","fillRect","$00387b554b88a86f$export$1ac198198c587660","$00387b554b88a86f$export$80b31447333fcc43","$00387b554b88a86f$export$ad58330ac2844faf","$00387b554b88a86f$export$14a5666d9e2a0a92","x4","y4","shape4","globalAlpha","beginPath","moveTo","lineTo","fill","x5","y5","strokeStyle","strokeRect","shape5","font","textBaseline","fillText","letter","$2ce087bca3075e18$export$3c5f89dae98e900b","n","random","$2ce087bca3075e18$export$114aa43ee4755930","array","length","focusTime","cursorIndex","onRun","gridPos","onSelection","forEach","rotation","addShape","pressedUp","pressedDown","removedShape","height","i","startX","startY","width","$00387b554b88a86f$export$9556950d702f9ce3","sin","closePath","stroke","progress","grid","word","builtWord","validGrid","onSuccess","setWord","reviewGrid","accept","cancel","renderLine","progressWidth","renderText","ctx1","offsetX","offsetY","ctx2","buttons","binding","w","h","$00387b554b88a86f$export$4a4fccf86f542a62","canvas","state","updateFromTouchEvent","event","canvasRect","getBoundingClientRect","newState","touch","targetTouches","clientX","clientY","button","$d12e779adf4758b5$var$CENTER_LEN","$d12e779adf4758b5$var$MAX_SHAPE_SIDE_LEN","blocks","isColumn","count","j","canSet","getIndex","set","value","countBlocks","recalculateCenter","bounds","top","bottom","validPositions","trueCenter","sort","posA","posB","abs","newCenter","updatedBlocks","i1","j1","oldX","oldY","transformedX","transformedY","$2a59e984b87de363$var$COLORS","$2a59e984b87de363$var$internalGenerateWordShapes","nextRun","colors","includes","$2a59e984b87de363$var$generateColors","colorOffset","$d12e779adf4758b5$export$2e2bcd8739ae039","spread","run","$09b17a1eda282565$export$2e2bcd8739ae039","$35da740d59af89ba$var$canvas","querySelector","$35da740d59af89ba$var$ctx","getContext","$35da740d59af89ba$var$game","inventory","$376aef2b802d0445$export$2e2bcd8739ae039","$30e9a94c591cfedc$export$2e2bcd8739ae039","runLine","$47117747e6c50692$export$2e2bcd8739ae039","focusedUI","$35d204e98b857052$export$2e2bcd8739ae039","Array","isArray","TypeError","newIndex","$d8bf78f2b5ef2882$export$2e2bcd8739ae039","$2a59e984b87de363$export$118f84f93f08b80c","focusOn","ui","isLandscape","window","innerHeight","innerWidth","$00387b554b88a86f$export$a94a52152a1b6dd0","$35da740d59af89ba$var$previousTime","$35da740d59af89ba$var$gameLoop","time","requestAnimationFrame"],"version":3,"file":"index.6e0f87ac.js.map"}